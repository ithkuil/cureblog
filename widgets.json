{ "_id" : { "$oid" : "4f34c3dc0000006f0a000002" }, "name" : "editor", "code" : "$(document).ready(function() {\n  \n  $('#savewidget').click(function() {\n    //htmlcm.save();\n    data = { name: $('#widgetname').val(),\n             code: $('#code').val(),\n             html: $('#html').val(),\n             css:  $('#css').val() };\n\n    var mode = $('#widgetname').data('mode');\n    if (mode == 'update') {\n      now.dbupdate('widgets', { name: data.name }, data);\n    } else {\n      now.dbinsert('widgets', data);             \n    }\n  });\n\n  now.ready(function() {\n\n    function editWidget(widget) {\n      $('#widgetname').data('mode', 'update');\n      htmlcm.setValue(widget.html);\n      $('#widgetname').val(widget.name);\n      $('#code').val(widget.code);\n      \n      $('#css').val(widget.css);\n    }\n\n    function widgetByName(name) {\n      for (var i=0; i<widgets.length; i++) {\n        if (widgets[i].name == name) {\n          return widgets[i];\n        }\n      }\n    }\n\n    //htmlcm = CodeMirror.fromTextArea($('#html')[0]);\n\n    now.dbfind('widgets', function(widgets) {\n      window.widgets = widgets;\n      var ul = '';\n      for (var i=0; i<widgets.length; i++) {\n        console.log(widgets[i]);\n        ul += '<li class=\"widgetsel\" data-name=\"' + widgets[i].name + '\" id=\"widget-\"' + widgets[i].name + '\">' + widgets[i].name + '</li>';  \n      } \n      $('#widgetlist').html(ul);\n      $('.widgetsel').click(function(ev) {\n        var name = $(ev.target).attr('data-name');\n        var widget = widgetByName(name);\n        editWidget(widget);         \n      });\n\n      $('#newwidget').click(function(ev) {\n        $('#widgetname').data('mode', 'new');\n        $('#widgetname, #code, #html, #css').val('');\n        \n      });\n    });\n  });\n  \n});\n\n\n", "html" : "Name:<br/>\n<input type=\"text\" id=\"widgetname\" />\n<br/>\nCode: <br/>\n<textarea id=\"code\"></textarea>\n\n<br/><br/>\n\nHTML: <br/>\n<textarea id=\"html\"></textarea>\n\n<br/><br/>\n\nCSS: <br/>\n<textarea id=\"css\"></textarea>\n\n<button id=\"savewidget\">Save</button>  <br/><br/>\n\n<button id=\"newwidget\">New</button>\n\n<ul id=\"widgetlist\"></ul>\n\n", "css" : "#code, #html, #css {\n  width: 800px;\n  height: 400px;\n}\n\n.CodeMirror {\n  border: 1px solid black;\n  width: 800px;\n  /* height: 370px; */\n}" }
{ "name" : "test", "code" : "//test", "html" : "", "css" : "", "_id" : { "$oid" : "4f34ca25000000960c000002" } }
{ "name" : "test2", "code" : "//t2", "html" : "", "css" : "", "_id" : { "$oid" : "4f34ca3d000000960c000003" } }
{ "_id" : { "$oid" : "4f34ca90000000960c000004" }, "name" : "codemirror", "code" : "// All functions that need access to the editor's state live inside\n// the CodeMirror function. Below that, at the bottom of the file,\n// some utilities are defined.\n\n// CodeMirror is the only global var we claim\nvar CodeMirror = (function() {\n  // This is the function that produces an editor instance. It's\n  // closure is used to store the editor state.\n  function CodeMirror(place, givenOptions) {\n    // Determine effective options based on given values and defaults.\n    var options = {}, defaults = CodeMirror.defaults;\n    for (var opt in defaults)\n      if (defaults.hasOwnProperty(opt))\n        options[opt] = (givenOptions && givenOptions.hasOwnProperty(opt) ? givenOptions : defaults)[opt];\n\n    var targetDocument = options[\"document\"];\n    // The element in which the editor lives.\n    var wrapper = targetDocument.createElement(\"div\");\n    wrapper.className = \"CodeMirror\" + (options.lineWrapping ? \" CodeMirror-wrap\" : \"\");\n    // This mess creates the base DOM structure for the editor.\n    wrapper.innerHTML =\n      '<div style=\"overflow: hidden; position: relative; width: 3px; height: 0px;\">' + // Wraps and hides input textarea\n        '<textarea style=\"position: absolute; padding: 0; width: 1px; height: 1em\" wrap=\"off\" ' +\n          'autocorrect=\"off\" autocapitalize=\"off\"></textarea></div>' +\n      '<div class=\"CodeMirror-scroll\" tabindex=\"-1\">' +\n        '<div style=\"position: relative\">' + // Set to the height of the text, causes scrolling\n          '<div style=\"position: relative\">' + // Moved around its parent to cover visible view\n            '<div class=\"CodeMirror-gutter\"><div class=\"CodeMirror-gutter-text\"></div></div>' +\n            // Provides positioning relative to (visible) text origin\n            '<div class=\"CodeMirror-lines\"><div style=\"position: relative; z-index: 0\">' +\n              '<div style=\"position: absolute; width: 100%; height: 0; overflow: hidden; visibility: hidden;\"></div>' +\n              '<pre class=\"CodeMirror-cursor\">&#160;</pre>' + // Absolutely positioned blinky cursor\n              '<div style=\"position: relative; z-index: -1\"></div><div></div>' + // DIVs containing the selection and the actual code\n            '</div></div></div></div></div>';\n    if (place.appendChild) place.appendChild(wrapper); else place(wrapper);\n    // I've never seen more elegant code in my life.\n    var inputDiv = wrapper.firstChild, input = inputDiv.firstChild,\n        scroller = wrapper.lastChild, code = scroller.firstChild,\n        mover = code.firstChild, gutter = mover.firstChild, gutterText = gutter.firstChild,\n        lineSpace = gutter.nextSibling.firstChild, measure = lineSpace.firstChild,\n        cursor = measure.nextSibling, selectionDiv = cursor.nextSibling,\n        lineDiv = selectionDiv.nextSibling;\n    themeChanged();\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) lineSpace.draggable = true;\n    lineSpace.style.outline = \"none\";\n    if (options.tabindex != null) input.tabIndex = options.tabindex;\n    if (!options.gutter && !options.lineNumbers) gutter.style.display = \"none\";\n\n    // Check for problem with IE innerHTML not working when we have a\n    // P (or similar) parent node.\n    try { stringWidth(\"x\"); }\n    catch (e) {\n      if (e.message.match(/runtime/i))\n        e = new Error(\"A CodeMirror inside a P-style element does not work in Internet Explorer. (innerHTML bug)\");\n      throw e;\n    }\n\n    // Delayed object wrap timeouts, making sure only one is active. blinker holds an interval.\n    var poll = new Delayed(), highlight = new Delayed(), blinker;\n\n    // mode holds a mode API object. doc is the tree of Line objects,\n    // work an array of lines that should be parsed, and history the\n    // undo history (instance of History constructor).\n    var mode, doc = new BranchChunk([new LeafChunk([new Line(\"\")])]), work, focused;\n    loadMode();\n    // The selection. These are always maintained to point at valid\n    // positions. Inverted is used to remember that the user is\n    // selecting bottom-to-top.\n    var sel = {from: {line: 0, ch: 0}, to: {line: 0, ch: 0}, inverted: false};\n    // Selection-related flags. shiftSelecting obviously tracks\n    // whether the user is holding shift.\n    var shiftSelecting, lastClick, lastDoubleClick, lastScrollPos = 0, draggingText,\n        overwrite = false, suppressEdits = false;\n    // Variables used by startOperation/endOperation to track what\n    // happened during the operation.\n    var updateInput, userSelChange, changes, textChanged, selectionChanged, leaveInputAlone,\n        gutterDirty, callbacks;\n    // Current visible range (may be bigger than the view window).\n    var displayOffset = 0, showingFrom = 0, showingTo = 0, lastSizeC = 0;\n    // bracketHighlighted is used to remember that a backet has been\n    // marked.\n    var bracketHighlighted;\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    var maxLine = \"\", maxWidth;\n\n    // Initialize the content.\n    operation(function(){setValue(options.value || \"\"); updateInput = false;})();\n    var history = new History();\n\n    // Register our event handlers.\n    connect(scroller, \"mousedown\", operation(onMouseDown));\n    connect(scroller, \"dblclick\", operation(onDoubleClick));\n    connect(lineSpace, \"dragstart\", onDragStart);\n    connect(lineSpace, \"selectstart\", e_preventDefault);\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!gecko) connect(scroller, \"contextmenu\", onContextMenu);\n    connect(scroller, \"scroll\", function() {\n      lastScrollPos = scroller.scrollTop;\n      updateDisplay([]);\n      if (options.fixedGutter) gutter.style.left = scroller.scrollLeft + \"px\";\n      if (options.onScroll) options.onScroll(instance);\n    });\n    connect(window, \"resize\", function() {updateDisplay(true);});\n    connect(input, \"keyup\", operation(onKeyUp));\n    connect(input, \"input\", fastPoll);\n    connect(input, \"keydown\", operation(onKeyDown));\n    connect(input, \"keypress\", operation(onKeyPress));\n    connect(input, \"focus\", onFocus);\n    connect(input, \"blur\", onBlur);\n\n    connect(scroller, \"dragenter\", e_stop);\n    connect(scroller, \"dragover\", e_stop);\n    connect(scroller, \"drop\", operation(onDrop));\n    connect(scroller, \"paste\", function(){focusInput(); fastPoll();});\n    connect(input, \"paste\", fastPoll);\n    connect(input, \"cut\", operation(function(){\n      if (!options.readOnly) replaceSelection(\"\");\n    }));\n\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (targetDocument.activeElement == input); } catch(e) { }\n    if (hasFocus) setTimeout(onFocus, 20);\n    else onBlur();\n\n    function isLine(l) {return l >= 0 && l < doc.size;}\n    // The instance object that we'll return. Mostly calls out to\n    // local functions in the CodeMirror function. Some do some extra\n    // range checking and/or clipping. operation is used to wrap the\n    // call so that changes it makes are tracked, and the display is\n    // updated afterwards.\n    var instance = wrapper.CodeMirror = {\n      getValue: getValue,\n      setValue: operation(setValue),\n      getSelection: getSelection,\n      replaceSelection: operation(replaceSelection),\n      focus: function(){focusInput(); onFocus(); fastPoll();},\n      setOption: function(option, value) {\n        var oldVal = options[option];\n        options[option] = value;\n        if (option == \"mode\" || option == \"indentUnit\") loadMode();\n        else if (option == \"readOnly\" && value == \"nocursor\") {onBlur(); input.blur();}\n        else if (option == \"readOnly\" && !value) {resetInput(true);}\n        else if (option == \"theme\") themeChanged();\n        else if (option == \"lineWrapping\" && oldVal != value) operation(wrappingChanged)();\n        else if (option == \"tabSize\") updateDisplay(true);\n        if (option == \"lineNumbers\" || option == \"gutter\" || option == \"firstLineNumber\" || option == \"theme\") {\n          gutterChanged();\n          updateDisplay(true);\n        }\n      },\n      getOption: function(option) {return options[option];},\n      undo: operation(undo),\n      redo: operation(redo),\n      indentLine: operation(function(n, dir) {\n        if (typeof dir != \"string\") {\n          if (dir == null) dir = options.smartIndent ? \"smart\" : \"prev\";\n          else dir = dir ? \"add\" : \"subtract\";\n        }\n        if (isLine(n)) indentLine(n, dir);\n      }),\n      indentSelection: operation(indentSelected),\n      historySize: function() {return {undo: history.done.length, redo: history.undone.length};},\n      clearHistory: function() {history = new History();},\n      matchBrackets: operation(function(){matchBrackets(true);}),\n      getTokenAt: operation(function(pos) {\n        pos = clipPos(pos);\n        return getLine(pos.line).getTokenAt(mode, getStateBefore(pos.line), pos.ch);\n      }),\n      getStateAfter: function(line) {\n        line = clipLine(line == null ? doc.size - 1: line);\n        return getStateBefore(line + 1);\n      },\n      cursorCoords: function(start){\n        if (start == null) start = sel.inverted;\n        return pageCoords(start ? sel.from : sel.to);\n      },\n      charCoords: function(pos){return pageCoords(clipPos(pos));},\n      coordsChar: function(coords) {\n        var off = eltOffset(lineSpace);\n        return coordsChar(coords.x - off.left, coords.y - off.top);\n      },\n      markText: operation(markText),\n      setBookmark: setBookmark,\n      setMarker: operation(addGutterMarker),\n      clearMarker: operation(removeGutterMarker),\n      setLineClass: operation(setLineClass),\n      hideLine: operation(function(h) {return setLineHidden(h, true);}),\n      showLine: operation(function(h) {return setLineHidden(h, false);}),\n      onDeleteLine: function(line, f) {\n        if (typeof line == \"number\") {\n          if (!isLine(line)) return null;\n          line = getLine(line);\n        }\n        (line.handlers || (line.handlers = [])).push(f);\n        return line;\n      },\n      lineInfo: lineInfo,\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        pos = localCoords(clipPos(pos));\n        var top = pos.yBot, left = pos.x;\n        node.style.position = \"absolute\";\n        code.appendChild(node);\n        if (vert == \"over\") top = pos.y;\n        else if (vert == \"near\") {\n          var vspace = Math.max(scroller.offsetHeight, doc.height * textHeight()),\n              hspace = Math.max(code.clientWidth, lineSpace.clientWidth) - paddingLeft();\n          if (pos.yBot + node.offsetHeight > vspace && pos.y > node.offsetHeight)\n            top = pos.y - node.offsetHeight;\n          if (left + node.offsetWidth > hspace)\n            left = hspace - node.offsetWidth;\n        }\n        node.style.top = (top + paddingTop()) + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = code.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") left = 0;\n          else if (horiz == \"middle\") left = (code.clientWidth - node.offsetWidth) / 2;\n          node.style.left = (left + paddingLeft()) + \"px\";\n        }\n        if (scroll)\n          scrollIntoView(left, top, left + node.offsetWidth, top + node.offsetHeight);\n      },\n\n      lineCount: function() {return doc.size;},\n      clipPos: clipPos,\n      getCursor: function(start) {\n        if (start == null) start = sel.inverted;\n        return copyPos(start ? sel.from : sel.to);\n      },\n      somethingSelected: function() {return !posEq(sel.from, sel.to);},\n      setCursor: operation(function(line, ch, user) {\n        if (ch == null && typeof line.line == \"number\") setCursor(line.line, line.ch, user);\n        else setCursor(line, ch, user);\n      }),\n      setSelection: operation(function(from, to, user) {\n        (user ? setSelectionUser : setSelection)(clipPos(from), clipPos(to || from));\n      }),\n      getLine: function(line) {if (isLine(line)) return getLine(line).text;},\n      getLineHandle: function(line) {if (isLine(line)) return getLine(line);},\n      setLine: operation(function(line, text) {\n        if (isLine(line)) replaceRange(text, {line: line, ch: 0}, {line: line, ch: getLine(line).text.length});\n      }),\n      removeLine: operation(function(line) {\n        if (isLine(line)) replaceRange(\"\", {line: line, ch: 0}, clipPos({line: line+1, ch: 0}));\n      }),\n      replaceRange: operation(replaceRange),\n      getRange: function(from, to) {return getRange(clipPos(from), clipPos(to));},\n\n      execCommand: function(cmd) {return commands[cmd](instance);},\n      // Stuff used by commands, probably not much use to outside code.\n      moveH: operation(moveH),\n      deleteH: operation(deleteH),\n      moveV: operation(moveV),\n      toggleOverwrite: function() {\n        if(overwrite){\n          overwrite = false;\n          cursor.className = cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n        } else {\n          overwrite = true;\n          cursor.className += \" CodeMirror-overwrite\";\n        }\n      },\n\n      posFromIndex: function(off) {\n        var lineNo = 0, ch;\n        doc.iter(0, doc.size, function(line) {\n          var sz = line.text.length + 1;\n          if (sz > off) { ch = off; return true; }\n          off -= sz;\n          ++lineNo;\n        });\n        return clipPos({line: lineNo, ch: ch});\n      },\n      indexFromPos: function (coords) {\n        if (coords.line < 0 || coords.ch < 0) return 0;\n        var index = coords.ch;\n        doc.iter(0, coords.line, function (line) {\n          index += line.text.length + 1;\n        });\n        return index;\n      },\n      scrollTo: function(x, y) {\n        if (x != null) scroller.scrollLeft = x;\n        if (y != null) scroller.scrollTop = y;\n        updateDisplay([]);\n      },\n\n      operation: function(f){return operation(f)();},\n      refresh: function(){\n        updateDisplay(true);\n        if (scroller.scrollHeight > lastScrollPos)\n          scroller.scrollTop = lastScrollPos;\n      },\n      getInputField: function(){return input;},\n      getWrapperElement: function(){return wrapper;},\n      getScrollerElement: function(){return scroller;},\n      getGutterElement: function(){return gutter;}\n    };\n\n    function getLine(n) { return getLineAt(doc, n); }\n    function updateLineHeight(line, height) {\n      gutterDirty = true;\n      var diff = height - line.height;\n      for (var n = line; n; n = n.parent) n.height += diff;\n    }\n\n    function setValue(code) {\n      var top = {line: 0, ch: 0};\n      updateLines(top, {line: doc.size - 1, ch: getLine(doc.size-1).text.length},\n                  splitLines(code), top, top);\n      updateInput = true;\n    }\n    function getValue(code) {\n      var text = [];\n      doc.iter(0, doc.size, function(line) { text.push(line.text); });\n      return text.join(\"\\n\");\n    }\n\n    function onMouseDown(e) {\n      setShift(e_prop(e, \"shiftKey\"));\n      // Check whether this is a click in a widget\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == code && n != mover) return;\n\n      // See if this is a click in the gutter\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == gutterText) {\n          if (options.onGutterClick)\n            options.onGutterClick(instance, indexOf(gutterText.childNodes, n) + showingFrom, e);\n          return e_preventDefault(e);\n        }\n\n      var start = posFromMouse(e);\n\n      switch (e_button(e)) {\n      case 3:\n        if (gecko && !mac) onContextMenu(e);\n        return;\n      case 2:\n        if (start) setCursor(start.line, start.ch, true);\n        return;\n      }\n      // For button 1, if it was clicked inside the editor\n      // (posFromMouse returning non-null), we have to adjust the\n      // selection.\n      if (!start) {if (e_target(e) == scroller) e_preventDefault(e); return;}\n\n      if (!focused) onFocus();\n\n      var now = +new Date;\n      if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n        e_preventDefault(e);\n        setTimeout(focusInput, 20);\n        return selectLine(start.line);\n      } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n        lastDoubleClick = {time: now, pos: start};\n        e_preventDefault(e);\n        return selectWordAt(start);\n      } else { lastClick = {time: now, pos: start}; }\n\n      var last = start, going;\n      if (dragAndDrop && !options.readOnly && !posEq(sel.from, sel.to) &&\n          !posLess(start, sel.from) && !posLess(sel.to, start)) {\n        // Let the drag handler handle this.\n        if (webkit) lineSpace.draggable = true;\n        var up = connect(targetDocument, \"mouseup\", operation(function(e2) {\n          if (webkit) lineSpace.draggable = false;\n          draggingText = false;\n          up();\n          if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n            e_preventDefault(e2);\n            setCursor(start.line, start.ch, true);\n            focusInput();\n          }\n        }), true);\n        draggingText = true;\n        return;\n      }\n      e_preventDefault(e);\n      setCursor(start.line, start.ch, true);\n\n      function extend(e) {\n        var cur = posFromMouse(e, true);\n        if (cur && !posEq(cur, last)) {\n          if (!focused) onFocus();\n          last = cur;\n          setSelectionUser(start, cur);\n          updateInput = false;\n          var visible = visibleLines();\n          if (cur.line >= visible.to || cur.line < visible.from)\n            going = setTimeout(operation(function(){extend(e);}), 150);\n        }\n      }\n\n      var move = connect(targetDocument, \"mousemove\", operation(function(e) {\n        clearTimeout(going);\n        e_preventDefault(e);\n        extend(e);\n      }), true);\n      var up = connect(targetDocument, \"mouseup\", operation(function(e) {\n        clearTimeout(going);\n        var cur = posFromMouse(e);\n        if (cur) setSelectionUser(start, cur);\n        e_preventDefault(e);\n        focusInput();\n        updateInput = true;\n        move(); up();\n      }), true);\n    }\n    function onDoubleClick(e) {\n      for (var n = e_target(e); n != wrapper; n = n.parentNode)\n        if (n.parentNode == gutterText) return e_preventDefault(e);\n      var start = posFromMouse(e);\n      if (!start) return;\n      lastDoubleClick = {time: +new Date, pos: start};\n      e_preventDefault(e);\n      selectWordAt(start);\n    }\n    function onDrop(e) {\n      e.preventDefault();\n      var pos = posFromMouse(e, true), files = e.dataTransfer.files;\n      if (!pos || options.readOnly) return;\n      if (files && files.length && window.FileReader && window.File) {\n        function loadFile(file, i) {\n          var reader = new FileReader;\n          reader.onload = function() {\n            text[i] = reader.result;\n            if (++read == n) {\n\t      pos = clipPos(pos);\n\t      operation(function() {\n                var end = replaceRange(text.join(\"\"), pos, pos);\n                setSelectionUser(pos, end);\n              })();\n\t    }\n          };\n          reader.readAsText(file);\n        }\n        var n = files.length, text = Array(n), read = 0;\n        for (var i = 0; i < n; ++i) loadFile(files[i], i);\n      }\n      else {\n        try {\n          var text = e.dataTransfer.getData(\"Text\");\n          if (text) {\n            var curFrom = sel.from, curTo = sel.to;\n            setSelectionUser(pos, pos);\n            if (draggingText) replaceRange(\"\", curFrom, curTo);\n            replaceSelection(text);\n\t    focusInput();\n\t  }\n        }\n        catch(e){}\n      }\n    }\n    function onDragStart(e) {\n      var txt = getSelection();\n      // This will reset escapeElement\n      htmlEscape(txt);\n      e.dataTransfer.setDragImage(escapeElement, 0, 0);\n      e.dataTransfer.setData(\"Text\", txt);\n    }\n    function handleKeyBinding(e) {\n      var name = keyNames[e_prop(e, \"keyCode\")], next = keyMap[options.keyMap].auto, bound, dropShift;\n      function handleNext() {\n        return next.call ? next.call(null, instance) : next;\n      }\n      if (name == null || e.altGraphKey) {\n        if (next) options.keyMap = handleNext();\n        return null;\n      }\n      if (e_prop(e, \"altKey\")) name = \"Alt-\" + name;\n      if (e_prop(e, \"ctrlKey\")) name = \"Ctrl-\" + name;\n      if (e_prop(e, \"metaKey\")) name = \"Cmd-\" + name;\n      if (e_prop(e, \"shiftKey\") &&\n          (bound = lookupKey(\"Shift-\" + name, options.extraKeys, options.keyMap))) {\n        dropShift = true;\n      } else {\n        bound = lookupKey(name, options.extraKeys, options.keyMap);\n      }\n      if (typeof bound == \"string\") {\n        if (commands.propertyIsEnumerable(bound)) bound = commands[bound];\n        else bound = null;\n      }\n      if (next && (bound || !isModifierKey(e))) options.keyMap = handleNext();\n      if (!bound) return false;\n      var prevShift = shiftSelecting;\n      try {\n        if (options.readOnly) suppressEdits = true;\n        if (dropShift) shiftSelecting = null;\n        bound(instance);\n      } finally {\n        shiftSelecting = prevShift;\n        suppressEdits = false;\n      }\n      e_preventDefault(e);\n      return true;\n    }\n    var lastStoppedKey = null;\n    function onKeyDown(e) {\n      if (!focused) onFocus();\n      if (ie && e.keyCode == 27) { e.returnValue = false; }\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      var code = e_prop(e, \"keyCode\");\n      // IE does strange things with escape.\n      setShift(code == 16 || e_prop(e, \"shiftKey\"));\n      // First give onKeyEvent option a chance to handle this.\n      var handled = handleKeyBinding(e);\n      if (window.opera) {\n        lastStoppedKey = handled ? code : null;\n        // Opera has no cut event... we try to at least catch the key combo\n        if (!handled && code == 88 && e_prop(e, mac ? \"metaKey\" : \"ctrlKey\"))\n          replaceSelection(\"\");\n      }\n    }\n    function onKeyPress(e) {\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      var keyCode = e_prop(e, \"keyCode\"), charCode = e_prop(e, \"charCode\");\n      if (window.opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n      if (window.opera && !e.which && handleKeyBinding(e)) return;\n      if (options.electricChars && mode.electricChars && options.smartIndent && !options.readOnly) {\n        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n        if (mode.electricChars.indexOf(ch) > -1)\n          setTimeout(operation(function() {indentLine(sel.to.line, \"smart\");}), 75);\n      }\n      fastPoll();\n    }\n    function onKeyUp(e) {\n      if (options.onKeyEvent && options.onKeyEvent(instance, addStop(e))) return;\n      if (e_prop(e, \"keyCode\") == 16) shiftSelecting = null;\n    }\n\n    function onFocus() {\n      if (options.readOnly == \"nocursor\") return;\n      if (!focused) {\n        if (options.onFocus) options.onFocus(instance);\n        focused = true;\n        if (wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n          wrapper.className += \" CodeMirror-focused\";\n        if (!leaveInputAlone) resetInput(true);\n      }\n      slowPoll();\n      restartBlink();\n    }\n    function onBlur() {\n      if (focused) {\n        if (options.onBlur) options.onBlur(instance);\n        focused = false;\n        if (bracketHighlighted)\n          operation(function(){\n            if (bracketHighlighted) { bracketHighlighted(); bracketHighlighted = null; }\n          })();\n        wrapper.className = wrapper.className.replace(\" CodeMirror-focused\", \"\");\n      }\n      clearInterval(blinker);\n      setTimeout(function() {if (!focused) shiftSelecting = null;}, 150);\n    }\n\n    // Replace the range from from to to by the strings in newText.\n    // Afterwards, set the selection to selFrom, selTo.\n    function updateLines(from, to, newText, selFrom, selTo) {\n      if (suppressEdits) return;\n      if (history) {\n        var old = [];\n        doc.iter(from.line, to.line + 1, function(line) { old.push(line.text); });\n        history.addChange(from.line, newText.length, old);\n        while (history.done.length > options.undoDepth) history.done.shift();\n      }\n      updateLinesNoUndo(from, to, newText, selFrom, selTo);\n    }\n    function unredoHelper(from, to, dir) {\n      var set = from.pop(), len = set ? set.length : 0, out = [];\n      for (var i = dir > 0 ? 0 : len - 1, e = dir > 0 ? len : -1; i != e; i += dir) {\n        var change = set[i];\n        var replaced = [], end = change.start + change.added;\n        doc.iter(change.start, end, function(line) { replaced.push(line.text); });\n        out.push({start: change.start, added: change.old.length, old: replaced});\n        var pos = clipPos({line: change.start + change.old.length - 1,\n                           ch: editEnd(replaced[replaced.length-1], change.old[change.old.length-1])});\n        updateLinesNoUndo({line: change.start, ch: 0}, {line: end - 1, ch: getLine(end-1).text.length}, change.old, pos, pos);\n      }\n      updateInput = true;\n      to.push(out);\n    }\n    function undo() {unredoHelper(history.done, history.undone, -1);}\n    function redo() {unredoHelper(history.undone, history.done, 1);}\n\n    function updateLinesNoUndo(from, to, newText, selFrom, selTo) {\n      if (suppressEdits) return;\n      var recomputeMaxLength = false, maxLineLength = maxLine.length;\n      if (!options.lineWrapping)\n        doc.iter(from.line, to.line, function(line) {\n          if (line.text.length == maxLineLength) {recomputeMaxLength = true; return true;}\n        });\n      if (from.line != to.line || newText.length > 1) gutterDirty = true;\n\n      var nlines = to.line - from.line, firstLine = getLine(from.line), lastLine = getLine(to.line);\n      // First adjust the line structure, taking some care to leave highlighting intact.\n      if (from.ch == 0 && to.ch == 0 && newText[newText.length - 1] == \"\") {\n        // This is a whole-line replace. Treated specially to make\n        // sure line objects move the way they are supposed to.\n        var added = [], prevLine = null;\n        if (from.line) {\n          prevLine = getLine(from.line - 1);\n          prevLine.fixMarkEnds(lastLine);\n        } else lastLine.fixMarkStarts();\n        for (var i = 0, e = newText.length - 1; i < e; ++i)\n          added.push(Line.inheritMarks(newText[i], prevLine));\n        if (nlines) doc.remove(from.line, nlines, callbacks);\n        if (added.length) doc.insert(from.line, added);\n      } else if (firstLine == lastLine) {\n        if (newText.length == 1)\n          firstLine.replace(from.ch, to.ch, newText[0]);\n        else {\n          lastLine = firstLine.split(to.ch, newText[newText.length-1]);\n          firstLine.replace(from.ch, null, newText[0]);\n          firstLine.fixMarkEnds(lastLine);\n          var added = [];\n          for (var i = 1, e = newText.length - 1; i < e; ++i)\n            added.push(Line.inheritMarks(newText[i], firstLine));\n          added.push(lastLine);\n          doc.insert(from.line + 1, added);\n        }\n      } else if (newText.length == 1) {\n        firstLine.replace(from.ch, null, newText[0]);\n        lastLine.replace(null, to.ch, \"\");\n        firstLine.append(lastLine);\n        doc.remove(from.line + 1, nlines, callbacks);\n      } else {\n        var added = [];\n        firstLine.replace(from.ch, null, newText[0]);\n        lastLine.replace(null, to.ch, newText[newText.length-1]);\n        firstLine.fixMarkEnds(lastLine);\n        for (var i = 1, e = newText.length - 1; i < e; ++i)\n          added.push(Line.inheritMarks(newText[i], firstLine));\n        if (nlines > 1) doc.remove(from.line + 1, nlines - 1, callbacks);\n        doc.insert(from.line + 1, added);\n      }\n      if (options.lineWrapping) {\n        var perLine = scroller.clientWidth / charWidth() - 3;\n        doc.iter(from.line, from.line + newText.length, function(line) {\n          if (line.hidden) return;\n          var guess = Math.ceil(line.text.length / perLine) || 1;\n          if (guess != line.height) updateLineHeight(line, guess);\n        });\n      } else {\n        doc.iter(from.line, i + newText.length, function(line) {\n          var l = line.text;\n          if (l.length > maxLineLength) {\n            maxLine = l; maxLineLength = l.length; maxWidth = null;\n            recomputeMaxLength = false;\n          }\n        });\n        if (recomputeMaxLength) {\n          maxLineLength = 0; maxLine = \"\"; maxWidth = null;\n          doc.iter(0, doc.size, function(line) {\n            var l = line.text;\n            if (l.length > maxLineLength) {\n              maxLineLength = l.length; maxLine = l;\n            }\n          });\n        }\n      }\n\n      // Add these lines to the work array, so that they will be\n      // highlighted. Adjust work lines if lines were added/removed.\n      var newWork = [], lendiff = newText.length - nlines - 1;\n      for (var i = 0, l = work.length; i < l; ++i) {\n        var task = work[i];\n        if (task < from.line) newWork.push(task);\n        else if (task > to.line) newWork.push(task + lendiff);\n      }\n      var hlEnd = from.line + Math.min(newText.length, 500);\n      highlightLines(from.line, hlEnd);\n      newWork.push(hlEnd);\n      work = newWork;\n      startWorker(100);\n      // Remember that these lines changed, for updating the display\n      changes.push({from: from.line, to: to.line + 1, diff: lendiff});\n      var changeObj = {from: from, to: to, text: newText};\n      if (textChanged) {\n        for (var cur = textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else textChanged = changeObj;\n\n      // Update the selection\n      function updateLine(n) {return n <= Math.min(to.line, to.line + lendiff) ? n : n + lendiff;}\n      setSelection(selFrom, selTo, updateLine(sel.from.line), updateLine(sel.to.line));\n\n      // Make sure the scroll-size div has the correct height.\n      if (scroller.clientHeight)\n        code.style.height = (doc.height * textHeight() + 2 * paddingTop()) + \"px\";\n    }\n\n    function replaceRange(code, from, to) {\n      from = clipPos(from);\n      if (!to) to = from; else to = clipPos(to);\n      code = splitLines(code);\n      function adjustPos(pos) {\n        if (posLess(pos, from)) return pos;\n        if (!posLess(to, pos)) return end;\n        var line = pos.line + code.length - (to.line - from.line) - 1;\n        var ch = pos.ch;\n        if (pos.line == to.line)\n          ch += code[code.length-1].length - (to.ch - (to.line == from.line ? from.ch : 0));\n        return {line: line, ch: ch};\n      }\n      var end;\n      replaceRange1(code, from, to, function(end1) {\n        end = end1;\n        return {from: adjustPos(sel.from), to: adjustPos(sel.to)};\n      });\n      return end;\n    }\n    function replaceSelection(code, collapse) {\n      replaceRange1(splitLines(code), sel.from, sel.to, function(end) {\n        if (collapse == \"end\") return {from: end, to: end};\n        else if (collapse == \"start\") return {from: sel.from, to: sel.from};\n        else return {from: sel.from, to: end};\n      });\n    }\n    function replaceRange1(code, from, to, computeSel) {\n      var endch = code.length == 1 ? code[0].length + from.ch : code[code.length-1].length;\n      var newSel = computeSel({line: from.line + code.length - 1, ch: endch});\n      updateLines(from, to, code, newSel.from, newSel.to);\n    }\n\n    function getRange(from, to) {\n      var l1 = from.line, l2 = to.line;\n      if (l1 == l2) return getLine(l1).text.slice(from.ch, to.ch);\n      var code = [getLine(l1).text.slice(from.ch)];\n      doc.iter(l1 + 1, l2, function(line) { code.push(line.text); });\n      code.push(getLine(l2).text.slice(0, to.ch));\n      return code.join(\"\\n\");\n    }\n    function getSelection() {\n      return getRange(sel.from, sel.to);\n    }\n\n    var pollingFast = false; // Ensures slowPoll doesn't cancel fastPoll\n    function slowPoll() {\n      if (pollingFast) return;\n      poll.set(options.pollInterval, function() {\n        startOperation();\n        readInput();\n        if (focused) slowPoll();\n        endOperation();\n      });\n    }\n    function fastPoll() {\n      var missed = false;\n      pollingFast = true;\n      function p() {\n        startOperation();\n        var changed = readInput();\n        if (!changed && !missed) {missed = true; poll.set(60, p);}\n        else {pollingFast = false; slowPoll();}\n        endOperation();\n      }\n      poll.set(20, p);\n    }\n\n    // Previnput is a hack to work with IME. If we reset the textarea\n    // on every change, that breaks IME. So we look for changes\n    // compared to the previous content instead. (Modern browsers have\n    // events that indicate IME taking place, but these are not widely\n    // supported or compatible enough yet to rely on.)\n    var prevInput = \"\";\n    function readInput() {\n      if (leaveInputAlone || !focused || hasSelection(input) || options.readOnly) return false;\n      var text = input.value;\n      if (text == prevInput) return false;\n      shiftSelecting = null;\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput[same] == text[same]) ++same;\n      if (same < prevInput.length)\n        sel.from = {line: sel.from.line, ch: sel.from.ch - (prevInput.length - same)};\n      else if (overwrite && posEq(sel.from, sel.to))\n        sel.to = {line: sel.to.line, ch: Math.min(getLine(sel.to.line).text.length, sel.to.ch + (text.length - same))};\n      replaceSelection(text.slice(same), \"end\");\n      prevInput = text;\n      return true;\n    }\n    function resetInput(user) {\n      if (!posEq(sel.from, sel.to)) {\n        prevInput = \"\";\n        input.value = getSelection();\n        selectInput(input);\n      } else if (user) prevInput = input.value = \"\";\n    }\n\n    function focusInput() {\n      if (options.readOnly != \"nocursor\") input.focus();\n    }\n\n    function scrollEditorIntoView() {\n      if (!cursor.getBoundingClientRect) return;\n      var rect = cursor.getBoundingClientRect();\n      // IE returns bogus coordinates when the instance sits inside of an iframe and the cursor is hidden\n      if (ie && rect.top == rect.bottom) return;\n      var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n      if (rect.top < 0 || rect.bottom > winH) cursor.scrollIntoView();\n    }\n    function scrollCursorIntoView() {\n      var cursor = localCoords(sel.inverted ? sel.from : sel.to);\n      var x = options.lineWrapping ? Math.min(cursor.x, lineSpace.offsetWidth) : cursor.x;\n      return scrollIntoView(x, cursor.y, x, cursor.yBot);\n    }\n    function scrollIntoView(x1, y1, x2, y2) {\n      var pl = paddingLeft(), pt = paddingTop(), lh = textHeight();\n      y1 += pt; y2 += pt; x1 += pl; x2 += pl;\n      var screen = scroller.clientHeight, screentop = scroller.scrollTop, scrolled = false, result = true;\n      if (y1 < screentop) {scroller.scrollTop = Math.max(0, y1 - 2*lh); scrolled = true;}\n      else if (y2 > screentop + screen) {scroller.scrollTop = y2 + lh - screen; scrolled = true;}\n\n      var screenw = scroller.clientWidth, screenleft = scroller.scrollLeft;\n      var gutterw = options.fixedGutter ? gutter.clientWidth : 0;\n      if (x1 < screenleft + gutterw) {\n        if (x1 < 50) x1 = 0;\n        scroller.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n        scrolled = true;\n      }\n      else if (x2 > screenw + screenleft - 3) {\n        scroller.scrollLeft = x2 + 10 - screenw;\n        scrolled = true;\n        if (x2 > code.clientWidth) result = false;\n      }\n      if (scrolled && options.onScroll) options.onScroll(instance);\n      return result;\n    }\n\n    function visibleLines() {\n      var lh = textHeight(), top = scroller.scrollTop - paddingTop();\n      var from_height = Math.max(0, Math.floor(top / lh));\n      var to_height = Math.ceil((top + scroller.clientHeight) / lh);\n      return {from: lineAtHeight(doc, from_height),\n              to: lineAtHeight(doc, to_height)};\n    }\n    // Uses a set of changes plus the current scroll position to\n    // determine which DOM updates have to be made, and makes the\n    // updates.\n    function updateDisplay(changes, suppressCallback) {\n      if (!scroller.clientWidth) {\n        showingFrom = showingTo = displayOffset = 0;\n        return;\n      }\n      // Compute the new visible window\n      var visible = visibleLines();\n      // Bail out if the visible area is already rendered and nothing changed.\n      if (changes !== true && changes.length == 0 && visible.from > showingFrom && visible.to < showingTo) return;\n      var from = Math.max(visible.from - 100, 0), to = Math.min(doc.size, visible.to + 100);\n      if (showingFrom < from && from - showingFrom < 20) from = showingFrom;\n      if (showingTo > to && showingTo - to < 20) to = Math.min(doc.size, showingTo);\n\n      // Create a range of theoretically intact lines, and punch holes\n      // in that using the change info.\n      var intact = changes === true ? [] :\n        computeIntact([{from: showingFrom, to: showingTo, domStart: 0}], changes);\n      // Clip off the parts that won't be visible\n      var intactLines = 0;\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i];\n        if (range.from < from) {range.domStart += (from - range.from); range.from = from;}\n        if (range.to > to) range.to = to;\n        if (range.from >= range.to) intact.splice(i--, 1);\n        else intactLines += range.to - range.from;\n      }\n      if (intactLines == to - from) return;\n      intact.sort(function(a, b) {return a.domStart - b.domStart;});\n\n      var th = textHeight(), gutterDisplay = gutter.style.display;\n      lineDiv.style.display = \"none\";\n      patchDisplay(from, to, intact);\n      lineDiv.style.display = gutter.style.display = \"\";\n\n      // Position the mover div to align with the lines it's supposed\n      // to be showing (which will cover the visible display)\n      var different = from != showingFrom || to != showingTo || lastSizeC != scroller.clientHeight + th;\n      // This is just a bogus formula that detects when the editor is\n      // resized or the font size changes.\n      if (different) lastSizeC = scroller.clientHeight + th;\n      showingFrom = from; showingTo = to;\n      displayOffset = heightAtLine(doc, from);\n      mover.style.top = (displayOffset * th) + \"px\";\n      if (scroller.clientHeight)\n        code.style.height = (doc.height * th + 2 * paddingTop()) + \"px\";\n\n      // Since this is all rather error prone, it is honoured with the\n      // only assertion in the whole file.\n      if (lineDiv.childNodes.length != showingTo - showingFrom)\n        throw new Error(\"BAD PATCH! \" + JSON.stringify(intact) + \" size=\" + (showingTo - showingFrom) +\n                        \" nodes=\" + lineDiv.childNodes.length);\n\n      if (options.lineWrapping) {\n        maxWidth = scroller.clientWidth;\n        var curNode = lineDiv.firstChild, heightChanged = false;\n        doc.iter(showingFrom, showingTo, function(line) {\n          if (!line.hidden) {\n            var height = Math.round(curNode.offsetHeight / th) || 1;\n            if (line.height != height) {\n              updateLineHeight(line, height);\n              gutterDirty = heightChanged = true;\n            }\n          }\n          curNode = curNode.nextSibling;\n        });\n        if (heightChanged)\n          code.style.height = (doc.height * th + 2 * paddingTop()) + \"px\";\n      } else {\n        if (maxWidth == null) maxWidth = stringWidth(maxLine);\n        if (maxWidth > scroller.clientWidth) {\n          lineSpace.style.width = maxWidth + \"px\";\n          // Needed to prevent odd wrapping/hiding of widgets placed in here.\n          code.style.width = \"\";\n          code.style.width = scroller.scrollWidth + \"px\";\n        } else {\n          lineSpace.style.width = code.style.width = \"\";\n        }\n      }\n      gutter.style.display = gutterDisplay;\n      if (different || gutterDirty) updateGutter();\n      updateSelection();\n      if (!suppressCallback && options.onUpdate) options.onUpdate(instance);\n      return true;\n    }\n\n    function computeIntact(intact, changes) {\n      for (var i = 0, l = changes.length || 0; i < l; ++i) {\n        var change = changes[i], intact2 = [], diff = change.diff || 0;\n        for (var j = 0, l2 = intact.length; j < l2; ++j) {\n          var range = intact[j];\n          if (change.to <= range.from && change.diff)\n            intact2.push({from: range.from + diff, to: range.to + diff,\n                          domStart: range.domStart});\n          else if (change.to <= range.from || change.from >= range.to)\n            intact2.push(range);\n          else {\n            if (change.from > range.from)\n              intact2.push({from: range.from, to: change.from, domStart: range.domStart});\n            if (change.to < range.to)\n              intact2.push({from: change.to + diff, to: range.to + diff,\n                            domStart: range.domStart + (change.to - range.from)});\n          }\n        }\n        intact = intact2;\n      }\n      return intact;\n    }\n\n    function patchDisplay(from, to, intact) {\n      // The first pass removes the DOM nodes that aren't intact.\n      if (!intact.length) lineDiv.innerHTML = \"\";\n      else {\n        function killNode(node) {\n          var tmp = node.nextSibling;\n          node.parentNode.removeChild(node);\n          return tmp;\n        }\n        var domPos = 0, curNode = lineDiv.firstChild, n;\n        for (var i = 0; i < intact.length; ++i) {\n          var cur = intact[i];\n          while (cur.domStart > domPos) {curNode = killNode(curNode); domPos++;}\n          for (var j = 0, e = cur.to - cur.from; j < e; ++j) {curNode = curNode.nextSibling; domPos++;}\n        }\n        while (curNode) curNode = killNode(curNode);\n      }\n      // This pass fills in the lines that actually changed.\n      var nextIntact = intact.shift(), curNode = lineDiv.firstChild, j = from;\n      var scratch = targetDocument.createElement(\"div\"), newElt;\n      doc.iter(from, to, function(line) {\n        if (nextIntact && nextIntact.to == j) nextIntact = intact.shift();\n        if (!nextIntact || nextIntact.from > j) {\n          if (line.hidden) var html = scratch.innerHTML = \"<pre></pre>\";\n          else {\n            var html = '<pre>' + line.getHTML(makeTab) + '</pre>';\n            // Kludge to make sure the styled element lies behind the selection (by z-index)\n            if (line.className)\n              html = '<div style=\"position: relative\"><pre class=\"' + line.className +\n              '\" style=\"position: absolute; left: 0; right: 0; top: 0; bottom: 0; z-index: -2\">&#160;</pre>' + html + \"</div>\";\n          }\n          scratch.innerHTML = html;\n          lineDiv.insertBefore(scratch.firstChild, curNode);\n        } else {\n          curNode = curNode.nextSibling;\n        }\n        ++j;\n      });\n    }\n\n    function updateGutter() {\n      if (!options.gutter && !options.lineNumbers) return;\n      var hText = mover.offsetHeight, hEditor = scroller.clientHeight;\n      gutter.style.height = (hText - hEditor < 2 ? hEditor : hText) + \"px\";\n      var html = [], i = showingFrom;\n      doc.iter(showingFrom, Math.max(showingTo, showingFrom + 1), function(line) {\n        if (line.hidden) {\n          html.push(\"<pre></pre>\");\n        } else {\n          var marker = line.gutterMarker;\n          var text = options.lineNumbers ? i + options.firstLineNumber : null;\n          if (marker && marker.text)\n            text = marker.text.replace(\"%N%\", text != null ? text : \"\");\n          else if (text == null)\n            text = \"\\u00a0\";\n          html.push((marker && marker.style ? '<pre class=\"' + marker.style + '\">' : \"<pre>\"), text);\n          for (var j = 1; j < line.height; ++j) html.push(\"<br/>&#160;\");\n          html.push(\"</pre>\");\n        }\n        ++i;\n      });\n      gutter.style.display = \"none\";\n      gutterText.innerHTML = html.join(\"\");\n      var minwidth = String(doc.size).length, firstNode = gutterText.firstChild, val = eltText(firstNode), pad = \"\";\n      while (val.length + pad.length < minwidth) pad += \"\\u00a0\";\n      if (pad) firstNode.insertBefore(targetDocument.createTextNode(pad), firstNode.firstChild);\n      gutter.style.display = \"\";\n      lineSpace.style.marginLeft = gutter.offsetWidth + \"px\";\n      gutterDirty = false;\n    }\n    function updateSelection() {\n      var collapsed = posEq(sel.from, sel.to);\n      var fromPos = localCoords(sel.from, true);\n      var toPos = collapsed ? fromPos : localCoords(sel.to, true);\n      var headPos = sel.inverted ? fromPos : toPos, th = textHeight();\n      var wrapOff = eltOffset(wrapper), lineOff = eltOffset(lineDiv);\n      inputDiv.style.top = Math.max(0, Math.min(scroller.offsetHeight, headPos.y + lineOff.top - wrapOff.top)) + \"px\";\n      inputDiv.style.left = Math.max(0, Math.min(scroller.offsetWidth, headPos.x + lineOff.left - wrapOff.left)) + \"px\";\n      if (collapsed) {\n        cursor.style.top = headPos.y + \"px\";\n        cursor.style.left = (options.lineWrapping ? Math.min(headPos.x, lineSpace.offsetWidth) : headPos.x) + \"px\";\n        cursor.style.display = \"\";\n        selectionDiv.style.display = \"none\";\n      } else {\n        var sameLine = fromPos.y == toPos.y, html = \"\";\n        function add(left, top, right, height) {\n          html += '<div class=\"CodeMirror-selected\" style=\"position: absolute; left: ' + left +\n            'px; top: ' + top + 'px; right: ' + right + 'px; height: ' + height + 'px\"></div>';\n        }\n        if (sel.from.ch && fromPos.y >= 0) {\n          var right = sameLine ? lineSpace.clientWidth - toPos.x : 0;\n          add(fromPos.x, fromPos.y, right, th);\n        }\n        var middleStart = Math.max(0, fromPos.y + (sel.from.ch ? th : 0));\n        var middleHeight = Math.min(toPos.y, lineSpace.clientHeight) - middleStart;\n        if (middleHeight > 0.2 * th)\n          add(0, middleStart, 0, middleHeight);\n        if ((!sameLine || !sel.from.ch) && toPos.y < lineSpace.clientHeight - .5 * th)\n          add(0, toPos.y, lineSpace.clientWidth - toPos.x, th);\n        selectionDiv.innerHTML = html;\n        cursor.style.display = \"none\";\n        selectionDiv.style.display = \"\";\n      }\n    }\n\n    function setShift(val) {\n      if (val) shiftSelecting = shiftSelecting || (sel.inverted ? sel.to : sel.from);\n      else shiftSelecting = null;\n    }\n    function setSelectionUser(from, to) {\n      var sh = shiftSelecting && clipPos(shiftSelecting);\n      if (sh) {\n        if (posLess(sh, from)) from = sh;\n        else if (posLess(to, sh)) to = sh;\n      }\n      setSelection(from, to);\n      userSelChange = true;\n    }\n    // Update the selection. Last two args are only used by\n    // updateLines, since they have to be expressed in the line\n    // numbers before the update.\n    function setSelection(from, to, oldFrom, oldTo) {\n      goalColumn = null;\n      if (oldFrom == null) {oldFrom = sel.from.line; oldTo = sel.to.line;}\n      if (posEq(sel.from, from) && posEq(sel.to, to)) return;\n      if (posLess(to, from)) {var tmp = to; to = from; from = tmp;}\n\n      // Skip over hidden lines.\n      if (from.line != oldFrom) from = skipHidden(from, oldFrom, sel.from.ch);\n      if (to.line != oldTo) to = skipHidden(to, oldTo, sel.to.ch);\n\n      if (posEq(from, to)) sel.inverted = false;\n      else if (posEq(from, sel.to)) sel.inverted = false;\n      else if (posEq(to, sel.from)) sel.inverted = true;\n\n      sel.from = from; sel.to = to;\n      selectionChanged = true;\n    }\n    function skipHidden(pos, oldLine, oldCh) {\n      function getNonHidden(dir) {\n        var lNo = pos.line + dir, end = dir == 1 ? doc.size : -1;\n        while (lNo != end) {\n          var line = getLine(lNo);\n          if (!line.hidden) {\n            var ch = pos.ch;\n            if (ch > oldCh || ch > line.text.length) ch = line.text.length;\n            return {line: lNo, ch: ch};\n          }\n          lNo += dir;\n        }\n      }\n      var line = getLine(pos.line);\n      if (!line.hidden) return pos;\n      if (pos.line >= oldLine) return getNonHidden(1) || getNonHidden(-1);\n      else return getNonHidden(-1) || getNonHidden(1);\n    }\n    function setCursor(line, ch, user) {\n      var pos = clipPos({line: line, ch: ch || 0});\n      (user ? setSelectionUser : setSelection)(pos, pos);\n    }\n\n    function clipLine(n) {return Math.max(0, Math.min(n, doc.size-1));}\n    function clipPos(pos) {\n      if (pos.line < 0) return {line: 0, ch: 0};\n      if (pos.line >= doc.size) return {line: doc.size-1, ch: getLine(doc.size-1).text.length};\n      var ch = pos.ch, linelen = getLine(pos.line).text.length;\n      if (ch == null || ch > linelen) return {line: pos.line, ch: linelen};\n      else if (ch < 0) return {line: pos.line, ch: 0};\n      else return pos;\n    }\n\n    function findPosH(dir, unit) {\n      var end = sel.inverted ? sel.from : sel.to, line = end.line, ch = end.ch;\n      var lineObj = getLine(line);\n      function findNextLine() {\n        for (var l = line + dir, e = dir < 0 ? -1 : doc.size; l != e; l += dir) {\n          var lo = getLine(l);\n          if (!lo.hidden) { line = l; lineObj = lo; return true; }\n        }\n      }\n      function moveOnce(boundToLine) {\n        if (ch == (dir < 0 ? 0 : lineObj.text.length)) {\n          if (!boundToLine && findNextLine()) ch = dir < 0 ? lineObj.text.length : 0;\n          else return false;\n        } else ch += dir;\n        return true;\n      }\n      if (unit == \"char\") moveOnce();\n      else if (unit == \"column\") moveOnce(true);\n      else if (unit == \"word\") {\n        var sawWord = false;\n        for (;;) {\n          if (dir < 0) if (!moveOnce()) break;\n          if (isWordChar(lineObj.text.charAt(ch))) sawWord = true;\n          else if (sawWord) {if (dir < 0) {dir = 1; moveOnce();} break;}\n          if (dir > 0) if (!moveOnce()) break;\n        }\n      }\n      return {line: line, ch: ch};\n    }\n    function moveH(dir, unit) {\n      var pos = dir < 0 ? sel.from : sel.to;\n      if (shiftSelecting || posEq(sel.from, sel.to)) pos = findPosH(dir, unit);\n      setCursor(pos.line, pos.ch, true);\n    }\n    function deleteH(dir, unit) {\n      if (!posEq(sel.from, sel.to)) replaceRange(\"\", sel.from, sel.to);\n      else if (dir < 0) replaceRange(\"\", findPosH(dir, unit), sel.to);\n      else replaceRange(\"\", sel.from, findPosH(dir, unit));\n      userSelChange = true;\n    }\n    var goalColumn = null;\n    function moveV(dir, unit) {\n      var dist = 0, pos = localCoords(sel.inverted ? sel.from : sel.to, true);\n      if (goalColumn != null) pos.x = goalColumn;\n      if (unit == \"page\") dist = Math.min(scroller.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      else if (unit == \"line\") dist = textHeight();\n      var target = coordsChar(pos.x, pos.y + dist * dir + 2);\n      setCursor(target.line, target.ch, true);\n      goalColumn = pos.x;\n    }\n\n    function selectWordAt(pos) {\n      var line = getLine(pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      while (start > 0 && isWordChar(line.charAt(start - 1))) --start;\n      while (end < line.length && isWordChar(line.charAt(end))) ++end;\n      setSelectionUser({line: pos.line, ch: start}, {line: pos.line, ch: end});\n    }\n    function selectLine(line) {\n      setSelectionUser({line: line, ch: 0}, {line: line, ch: getLine(line).text.length});\n    }\n    function indentSelected(mode) {\n      if (posEq(sel.from, sel.to)) return indentLine(sel.from.line, mode);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(i, mode);\n    }\n\n    function indentLine(n, how) {\n      if (!how) how = \"add\";\n      if (how == \"smart\") {\n        if (!mode.indent) how = \"prev\";\n        else var state = getStateBefore(n);\n      }\n\n      var line = getLine(n), curSpace = line.indentation(options.tabSize),\n          curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n      if (how == \"prev\") {\n        if (n) indentation = getLine(n-1).indentation(options.tabSize);\n        else indentation = 0;\n      }\n      else if (how == \"smart\") indentation = mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      else if (how == \"add\") indentation = curSpace + options.indentUnit;\n      else if (how == \"subtract\") indentation = curSpace - options.indentUnit;\n      indentation = Math.max(0, indentation);\n      var diff = indentation - curSpace;\n\n      if (!diff) {\n        if (sel.from.line != n && sel.to.line != n) return;\n        var indentString = curSpaceString;\n      }\n      else {\n        var indentString = \"\", pos = 0;\n        if (options.indentWithTabs)\n          for (var i = Math.floor(indentation / options.tabSize); i; --i) {pos += options.tabSize; indentString += \"\\t\";}\n        while (pos < indentation) {++pos; indentString += \" \";}\n      }\n\n      replaceRange(indentString, {line: n, ch: 0}, {line: n, ch: curSpaceString.length});\n    }\n\n    function loadMode() {\n      mode = CodeMirror.getMode(options, options.mode);\n      doc.iter(0, doc.size, function(line) { line.stateAfter = null; });\n      work = [0];\n      startWorker();\n    }\n    function gutterChanged() {\n      var visible = options.gutter || options.lineNumbers;\n      gutter.style.display = visible ? \"\" : \"none\";\n      if (visible) gutterDirty = true;\n      else lineDiv.parentNode.style.marginLeft = 0;\n    }\n    function wrappingChanged(from, to) {\n      if (options.lineWrapping) {\n        wrapper.className += \" CodeMirror-wrap\";\n        var perLine = scroller.clientWidth / charWidth() - 3;\n        doc.iter(0, doc.size, function(line) {\n          if (line.hidden) return;\n          var guess = Math.ceil(line.text.length / perLine) || 1;\n          if (guess != 1) updateLineHeight(line, guess);\n        });\n        lineSpace.style.width = code.style.width = \"\";\n      } else {\n        wrapper.className = wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n        maxWidth = null; maxLine = \"\";\n        doc.iter(0, doc.size, function(line) {\n          if (line.height != 1 && !line.hidden) updateLineHeight(line, 1);\n          if (line.text.length > maxLine.length) maxLine = line.text;\n        });\n      }\n      changes.push({from: 0, to: doc.size});\n    }\n    function makeTab(col) {\n      var w = options.tabSize - col % options.tabSize;\n      for (var str = '<span class=\"cm-tab\">', i = 0; i < w; ++i) str += \" \";\n      return {html: str + \"</span>\", width: w};\n    }\n    function themeChanged() {\n      scroller.className = scroller.className.replace(/\\s*cm-s-\\w+/g, \"\") +\n        options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    }\n\n    function TextMarker() { this.set = []; }\n    TextMarker.prototype.clear = operation(function() {\n      var min = Infinity, max = -Infinity;\n      for (var i = 0, e = this.set.length; i < e; ++i) {\n        var line = this.set[i], mk = line.marked;\n        if (!mk || !line.parent) continue;\n        var lineN = lineNo(line);\n        min = Math.min(min, lineN); max = Math.max(max, lineN);\n        for (var j = 0; j < mk.length; ++j)\n          if (mk[j].set == this.set) mk.splice(j--, 1);\n      }\n      if (min != Infinity)\n        changes.push({from: min, to: max + 1});\n    });\n    TextMarker.prototype.find = function() {\n      var from, to;\n      for (var i = 0, e = this.set.length; i < e; ++i) {\n        var line = this.set[i], mk = line.marked;\n        for (var j = 0; j < mk.length; ++j) {\n          var mark = mk[j];\n          if (mark.set == this.set) {\n            if (mark.from != null || mark.to != null) {\n              var found = lineNo(line);\n              if (found != null) {\n                if (mark.from != null) from = {line: found, ch: mark.from};\n                if (mark.to != null) to = {line: found, ch: mark.to};\n              }\n            }\n          }\n        }\n      }\n      return {from: from, to: to};\n    };\n\n    function markText(from, to, className) {\n      from = clipPos(from); to = clipPos(to);\n      var tm = new TextMarker();\n      function add(line, from, to, className) {\n        getLine(line).addMark(new MarkedText(from, to, className, tm.set));\n      }\n      if (from.line == to.line) add(from.line, from.ch, to.ch, className);\n      else {\n        add(from.line, from.ch, null, className);\n        for (var i = from.line + 1, e = to.line; i < e; ++i)\n          add(i, null, null, className);\n        add(to.line, null, to.ch, className);\n      }\n      changes.push({from: from.line, to: to.line + 1});\n      return tm;\n    }\n\n    function setBookmark(pos) {\n      pos = clipPos(pos);\n      var bm = new Bookmark(pos.ch);\n      getLine(pos.line).addMark(bm);\n      return bm;\n    }\n\n    function addGutterMarker(line, text, className) {\n      if (typeof line == \"number\") line = getLine(clipLine(line));\n      line.gutterMarker = {text: text, style: className};\n      gutterDirty = true;\n      return line;\n    }\n    function removeGutterMarker(line) {\n      if (typeof line == \"number\") line = getLine(clipLine(line));\n      line.gutterMarker = null;\n      gutterDirty = true;\n    }\n\n    function changeLine(handle, op) {\n      var no = handle, line = handle;\n      if (typeof handle == \"number\") line = getLine(clipLine(handle));\n      else no = lineNo(handle);\n      if (no == null) return null;\n      if (op(line, no)) changes.push({from: no, to: no + 1});\n      else return null;\n      return line;\n    }\n    function setLineClass(handle, className) {\n      return changeLine(handle, function(line) {\n        if (line.className != className) {\n          line.className = className;\n          return true;\n        }\n      });\n    }\n    function setLineHidden(handle, hidden) {\n      return changeLine(handle, function(line, no) {\n        if (line.hidden != hidden) {\n          line.hidden = hidden;\n          updateLineHeight(line, hidden ? 0 : 1);\n          var fline = sel.from.line, tline = sel.to.line;\n          if (hidden && (fline == no || tline == no)) {\n            var from = fline == no ? skipHidden({line: fline, ch: 0}, fline, 0) : sel.from;\n            var to = tline == no ? skipHidden({line: tline, ch: 0}, tline, 0) : sel.to;\n            setSelection(from, to);\n          }\n          return (gutterDirty = true);\n        }\n      });\n    }\n\n    function lineInfo(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(line)) return null;\n        var n = line;\n        line = getLine(line);\n        if (!line) return null;\n      }\n      else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      var marker = line.gutterMarker;\n      return {line: n, handle: line, text: line.text, markerText: marker && marker.text,\n              markerClass: marker && marker.style, lineClass: line.className};\n    }\n\n    function stringWidth(str) {\n      measure.innerHTML = \"<pre><span>x</span></pre>\";\n      measure.firstChild.firstChild.firstChild.nodeValue = str;\n      return measure.firstChild.firstChild.offsetWidth || 10;\n    }\n    // These are used to go from pixel positions to character\n    // positions, taking varying character widths into account.\n    function charFromX(line, x) {\n      if (x <= 0) return 0;\n      var lineObj = getLine(line), text = lineObj.text;\n      function getX(len) {\n        measure.innerHTML = \"<pre><span>\" + lineObj.getHTML(makeTab, len) + \"</span></pre>\";\n        return measure.firstChild.firstChild.offsetWidth;\n      }\n      var from = 0, fromX = 0, to = text.length, toX;\n      // Guess a suitable upper bound for our search.\n      var estimated = Math.min(to, Math.ceil(x / charWidth()));\n      for (;;) {\n        var estX = getX(estimated);\n        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));\n        else {toX = estX; to = estimated; break;}\n      }\n      if (x > toX) return to;\n      // Try to guess a suitable lower bound as well.\n      estimated = Math.floor(to * 0.8); estX = getX(estimated);\n      if (estX < x) {from = estimated; fromX = estX;}\n      // Do a binary search between these bounds.\n      for (;;) {\n        if (to - from <= 1) return (toX - x > x - fromX) ? from : to;\n        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);\n        if (middleX > x) {to = middle; toX = middleX;}\n        else {from = middle; fromX = middleX;}\n      }\n    }\n\n    var tempId = Math.floor(Math.random() * 0xffffff).toString(16);\n    function measureLine(line, ch) {\n      if (ch == 0) return {top: 0, left: 0};\n      var extra = \"\";\n      // Include extra text at the end to make sure the measured line is wrapped in the right way.\n      if (options.lineWrapping) {\n        var end = line.text.indexOf(\" \", ch + 2);\n        extra = htmlEscape(line.text.slice(ch + 1, end < 0 ? line.text.length : end + (ie ? 5 : 0)));\n      }\n      measure.innerHTML = \"<pre>\" + line.getHTML(makeTab, ch) +\n        '<span id=\"CodeMirror-temp-' + tempId + '\">' + htmlEscape(line.text.charAt(ch) || \" \") + \"</span>\" +\n        extra + \"</pre>\";\n      var elt = document.getElementById(\"CodeMirror-temp-\" + tempId);\n      var top = elt.offsetTop, left = elt.offsetLeft;\n      // Older IEs report zero offsets for spans directly after a wrap\n      if (ie && top == 0 && left == 0) {\n        var backup = document.createElement(\"span\");\n        backup.innerHTML = \"x\";\n        elt.parentNode.insertBefore(backup, elt.nextSibling);\n        top = backup.offsetTop;\n      }\n      return {top: top, left: left};\n    }\n    function localCoords(pos, inLineWrap) {\n      var x, lh = textHeight(), y = lh * (heightAtLine(doc, pos.line) - (inLineWrap ? displayOffset : 0));\n      if (pos.ch == 0) x = 0;\n      else {\n        var sp = measureLine(getLine(pos.line), pos.ch);\n        x = sp.left;\n        if (options.lineWrapping) y += Math.max(0, sp.top);\n      }\n      return {x: x, y: y, yBot: y + lh};\n    }\n    // Coords must be lineSpace-local\n    function coordsChar(x, y) {\n      if (y < 0) y = 0;\n      var th = textHeight(), cw = charWidth(), heightPos = displayOffset + Math.floor(y / th);\n      var lineNo = lineAtHeight(doc, heightPos);\n      if (lineNo >= doc.size) return {line: doc.size - 1, ch: getLine(doc.size - 1).text.length};\n      var lineObj = getLine(lineNo), text = lineObj.text;\n      var tw = options.lineWrapping, innerOff = tw ? heightPos - heightAtLine(doc, lineNo) : 0;\n      if (x <= 0 && innerOff == 0) return {line: lineNo, ch: 0};\n      function getX(len) {\n        var sp = measureLine(lineObj, len);\n        if (tw) {\n          var off = Math.round(sp.top / th);\n          return Math.max(0, sp.left + (off - innerOff) * scroller.clientWidth);\n        }\n        return sp.left;\n      }\n      var from = 0, fromX = 0, to = text.length, toX;\n      // Guess a suitable upper bound for our search.\n      var estimated = Math.min(to, Math.ceil((x + innerOff * scroller.clientWidth * .9) / cw));\n      for (;;) {\n        var estX = getX(estimated);\n        if (estX <= x && estimated < to) estimated = Math.min(to, Math.ceil(estimated * 1.2));\n        else {toX = estX; to = estimated; break;}\n      }\n      if (x > toX) return {line: lineNo, ch: to};\n      // Try to guess a suitable lower bound as well.\n      estimated = Math.floor(to * 0.8); estX = getX(estimated);\n      if (estX < x) {from = estimated; fromX = estX;}\n      // Do a binary search between these bounds.\n      for (;;) {\n        if (to - from <= 1) return {line: lineNo, ch: (toX - x > x - fromX) ? from : to};\n        var middle = Math.ceil((from + to) / 2), middleX = getX(middle);\n        if (middleX > x) {to = middle; toX = middleX;}\n        else {from = middle; fromX = middleX;}\n      }\n    }\n    function pageCoords(pos) {\n      var local = localCoords(pos, true), off = eltOffset(lineSpace);\n      return {x: off.left + local.x, y: off.top + local.y, yBot: off.top + local.yBot};\n    }\n\n    var cachedHeight, cachedHeightFor, measureText;\n    function textHeight() {\n      if (measureText == null) {\n        measureText = \"<pre>\";\n        for (var i = 0; i < 49; ++i) measureText += \"x<br/>\";\n        measureText += \"x</pre>\";\n      }\n      var offsetHeight = lineDiv.clientHeight;\n      if (offsetHeight == cachedHeightFor) return cachedHeight;\n      cachedHeightFor = offsetHeight;\n      measure.innerHTML = measureText;\n      cachedHeight = measure.firstChild.offsetHeight / 50 || 1;\n      measure.innerHTML = \"\";\n      return cachedHeight;\n    }\n    var cachedWidth, cachedWidthFor = 0;\n    function charWidth() {\n      if (scroller.clientWidth == cachedWidthFor) return cachedWidth;\n      cachedWidthFor = scroller.clientWidth;\n      return (cachedWidth = stringWidth(\"x\"));\n    }\n    function paddingTop() {return lineSpace.offsetTop;}\n    function paddingLeft() {return lineSpace.offsetLeft;}\n\n    function posFromMouse(e, liberal) {\n      var offW = eltOffset(scroller, true), x, y;\n      // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n      try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n      // This is a mess of a heuristic to try and determine whether a\n      // scroll-bar was clicked or not, and to return null if one was\n      // (and !liberal).\n      if (!liberal && (x - offW.left > scroller.clientWidth || y - offW.top > scroller.clientHeight))\n        return null;\n      var offL = eltOffset(lineSpace, true);\n      return coordsChar(x - offL.left, y - offL.top);\n    }\n    function onContextMenu(e) {\n      var pos = posFromMouse(e);\n      if (!pos || window.opera) return; // Opera is difficult.\n      if (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to))\n        operation(setCursor)(pos.line, pos.ch);\n\n      var oldCSS = input.style.cssText;\n      inputDiv.style.position = \"absolute\";\n      input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n        \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: white; \" +\n        \"border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      leaveInputAlone = true;\n      var val = input.value = getSelection();\n      focusInput();\n      selectInput(input);\n      function rehide() {\n        var newVal = splitLines(input.value).join(\"\\n\");\n        if (newVal != val) operation(replaceSelection)(newVal, \"end\");\n        inputDiv.style.position = \"relative\";\n        input.style.cssText = oldCSS;\n        leaveInputAlone = false;\n        resetInput(true);\n        slowPoll();\n      }\n\n      if (gecko) {\n        e_stop(e);\n        var mouseup = connect(window, \"mouseup\", function() {\n          mouseup();\n          setTimeout(rehide, 20);\n        }, true);\n      }\n      else {\n        setTimeout(rehide, 50);\n      }\n    }\n\n    // Cursor-blinking\n    function restartBlink() {\n      clearInterval(blinker);\n      var on = true;\n      cursor.style.visibility = \"\";\n      blinker = setInterval(function() {\n        cursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, 650);\n    }\n\n    var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n    function matchBrackets(autoclear) {\n      var head = sel.inverted ? sel.from : sel.to, line = getLine(head.line), pos = head.ch - 1;\n      var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n      if (!match) return;\n      var ch = match.charAt(0), forward = match.charAt(1) == \">\", d = forward ? 1 : -1, st = line.styles;\n      for (var off = pos + 1, i = 0, e = st.length; i < e; i+=2)\n        if ((off -= st[i].length) <= 0) {var style = st[i+1]; break;}\n\n      var stack = [line.text.charAt(pos)], re = /[(){}[\\]]/;\n      function scan(line, from, to) {\n        if (!line.text) return;\n        var st = line.styles, pos = forward ? 0 : line.text.length - 1, cur;\n        for (var i = forward ? 0 : st.length - 2, e = forward ? st.length : -2; i != e; i += 2*d) {\n          var text = st[i];\n          if (st[i+1] != null && st[i+1] != style) {pos += d * text.length; continue;}\n          for (var j = forward ? 0 : text.length - 1, te = forward ? text.length : -1; j != te; j += d, pos+=d) {\n            if (pos >= from && pos < to && re.test(cur = text.charAt(j))) {\n              var match = matching[cur];\n              if (match.charAt(1) == \">\" == forward) stack.push(cur);\n              else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};\n              else if (!stack.length) return {pos: pos, match: true};\n            }\n          }\n        }\n      }\n      for (var i = head.line, e = forward ? Math.min(i + 100, doc.size) : Math.max(-1, i - 100); i != e; i+=d) {\n        var line = getLine(i), first = i == head.line;\n        var found = scan(line, first && forward ? pos + 1 : 0, first && !forward ? pos : line.text.length);\n        if (found) break;\n      }\n      if (!found) found = {pos: null, match: false};\n      var style = found.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n      var one = markText({line: head.line, ch: pos}, {line: head.line, ch: pos+1}, style),\n          two = found.pos != null && markText({line: i, ch: found.pos}, {line: i, ch: found.pos + 1}, style);\n      var clear = operation(function(){one.clear(); two && two.clear();});\n      if (autoclear) setTimeout(clear, 800);\n      else bracketHighlighted = clear;\n    }\n\n    // Finds the line to start with when starting a parse. Tries to\n    // find a line with a stateAfter, so that it can start with a\n    // valid state. If that fails, it returns the line with the\n    // smallest indentation, which tends to need the least context to\n    // parse correctly.\n    function findStartLine(n) {\n      var minindent, minline;\n      for (var search = n, lim = n - 40; search > lim; --search) {\n        if (search == 0) return 0;\n        var line = getLine(search-1);\n        if (line.stateAfter) return search;\n        var indented = line.indentation(options.tabSize);\n        if (minline == null || minindent > indented) {\n          minline = search - 1;\n          minindent = indented;\n        }\n      }\n      return minline;\n    }\n    function getStateBefore(n) {\n      var start = findStartLine(n), state = start && getLine(start-1).stateAfter;\n      if (!state) state = startState(mode);\n      else state = copyState(mode, state);\n      doc.iter(start, n, function(line) {\n        line.highlight(mode, state, options.tabSize);\n        line.stateAfter = copyState(mode, state);\n      });\n      if (start < n) changes.push({from: start, to: n});\n      if (n < doc.size && !getLine(n).stateAfter) work.push(n);\n      return state;\n    }\n    function highlightLines(start, end) {\n      var state = getStateBefore(start);\n      doc.iter(start, end, function(line) {\n        line.highlight(mode, state, options.tabSize);\n        line.stateAfter = copyState(mode, state);\n      });\n    }\n    function highlightWorker() {\n      var end = +new Date + options.workTime;\n      var foundWork = work.length;\n      while (work.length) {\n        if (!getLine(showingFrom).stateAfter) var task = showingFrom;\n        else var task = work.pop();\n        if (task >= doc.size) continue;\n        var start = findStartLine(task), state = start && getLine(start-1).stateAfter;\n        if (state) state = copyState(mode, state);\n        else state = startState(mode);\n\n        var unchanged = 0, compare = mode.compareStates, realChange = false,\n            i = start, bail = false;\n        doc.iter(i, doc.size, function(line) {\n          var hadState = line.stateAfter;\n          if (+new Date > end) {\n            work.push(i);\n            startWorker(options.workDelay);\n            if (realChange) changes.push({from: task, to: i + 1});\n            return (bail = true);\n          }\n          var changed = line.highlight(mode, state, options.tabSize);\n          if (changed) realChange = true;\n          line.stateAfter = copyState(mode, state);\n          if (compare) {\n            if (hadState && compare(hadState, state)) return true;\n          } else {\n            if (changed !== false || !hadState) unchanged = 0;\n            else if (++unchanged > 3 && (!mode.indent || mode.indent(hadState, \"\") == mode.indent(state, \"\")))\n              return true;\n          }\n          ++i;\n        });\n        if (bail) return;\n        if (realChange) changes.push({from: task, to: i + 1});\n      }\n      if (foundWork && options.onHighlightComplete)\n        options.onHighlightComplete(instance);\n    }\n    function startWorker(time) {\n      if (!work.length) return;\n      highlight.set(time, operation(highlightWorker));\n    }\n\n    // Operations are used to wrap changes in such a way that each\n    // change won't have to update the cursor and display (which would\n    // be awkward, slow, and error-prone), but instead updates are\n    // batched and then all combined and executed at once.\n    function startOperation() {\n      updateInput = userSelChange = textChanged = null;\n      changes = []; selectionChanged = false; callbacks = [];\n    }\n    function endOperation() {\n      var reScroll = false, updated;\n      if (selectionChanged) reScroll = !scrollCursorIntoView();\n      if (changes.length) updated = updateDisplay(changes, true);\n      else {\n        if (selectionChanged) updateSelection();\n        if (gutterDirty) updateGutter();\n      }\n      if (reScroll) scrollCursorIntoView();\n      if (selectionChanged) {scrollEditorIntoView(); restartBlink();}\n\n      if (focused && !leaveInputAlone &&\n          (updateInput === true || (updateInput !== false && selectionChanged)))\n        resetInput(userSelChange);\n\n      if (selectionChanged && options.matchBrackets)\n        setTimeout(operation(function() {\n          if (bracketHighlighted) {bracketHighlighted(); bracketHighlighted = null;}\n          if (posEq(sel.from, sel.to)) matchBrackets(false);\n        }), 20);\n      var tc = textChanged, cbs = callbacks; // these can be reset by callbacks\n      if (selectionChanged && options.onCursorActivity)\n        options.onCursorActivity(instance);\n      if (tc && options.onChange && instance)\n        options.onChange(instance, tc);\n      for (var i = 0; i < cbs.length; ++i) cbs[i](instance);\n      if (updated && options.onUpdate) options.onUpdate(instance);\n    }\n    var nestedOperation = 0;\n    function operation(f) {\n      return function() {\n        if (!nestedOperation++) startOperation();\n        try {var result = f.apply(this, arguments);}\n        finally {if (!--nestedOperation) endOperation();}\n        return result;\n      };\n    }\n\n    for (var ext in extensions)\n      if (extensions.propertyIsEnumerable(ext) &&\n          !instance.propertyIsEnumerable(ext))\n        instance[ext] = extensions[ext];\n    return instance;\n  } // (end of function CodeMirror)\n\n  // The default configuration options.\n  CodeMirror.defaults = {\n    value: \"\",\n    mode: null,\n    theme: \"default\",\n    indentUnit: 2,\n    indentWithTabs: false,\n    smartIndent: true,\n    tabSize: 4,\n    keyMap: \"default\",\n    extraKeys: null,\n    electricChars: true,\n    onKeyEvent: null,\n    lineWrapping: false,\n    lineNumbers: false,\n    gutter: false,\n    fixedGutter: false,\n    firstLineNumber: 1,\n    readOnly: false,\n    onChange: null,\n    onCursorActivity: null,\n    onGutterClick: null,\n    onHighlightComplete: null,\n    onUpdate: null,\n    onFocus: null, onBlur: null, onScroll: null,\n    matchBrackets: false,\n    workTime: 100,\n    workDelay: 200,\n    pollInterval: 100,\n    undoDepth: 40,\n    tabindex: null,\n    document: window.document\n  };\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var win = /Win/.test(navigator.platform);\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    modes[name] = mode;\n  };\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n  CodeMirror.getMode = function(options, spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec))\n      spec = mimeModes[spec];\n    if (typeof spec == \"string\")\n      var mname = spec, config = {};\n    else if (spec != null)\n      var mname = spec.name, config = spec;\n    var mfactory = modes[mname];\n    if (!mfactory) {\n      if (window.console) console.warn(\"No mode \" + mname + \" found, falling back to plain text.\");\n      return CodeMirror.getMode(options, \"text/plain\");\n    }\n    return mfactory(options, config || {});\n  };\n  CodeMirror.listModes = function() {\n    var list = [];\n    for (var m in modes)\n      if (modes.propertyIsEnumerable(m)) list.push(m);\n    return list;\n  };\n  CodeMirror.listMIMEs = function() {\n    var list = [];\n    for (var m in mimeModes)\n      if (mimeModes.propertyIsEnumerable(m)) list.push({mime: m, mode: mimeModes[m]});\n    return list;\n  };\n\n  var extensions = CodeMirror.extensions = {};\n  CodeMirror.defineExtension = function(name, func) {\n    extensions[name] = func;\n  };\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection({line: 0, ch: 0}, {line: cm.lineCount() - 1});},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch) cm.replaceRange(\"\", from, {line: from.line + 1, ch: 0});\n      else cm.replaceRange(\"\", from, sel ? to : {line: from.line});\n    },\n    deleteLine: function(cm) {var l = cm.getCursor().line; cm.replaceRange(\"\", {line: l, ch: 0}, {line: l});},\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.setCursor(0, 0, true);},\n    goDocEnd: function(cm) {cm.setSelection({line: cm.lineCount() - 1}, null, true);},\n    goLineStart: function(cm) {cm.setCursor(cm.getCursor().line, 0, true);},\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor();\n      var text = cm.getLine(cur.line), firstNonWS = Math.max(0, text.search(/\\S/));\n      cm.setCursor(cur.line, cur.ch <= firstNonWS && cur.ch ? 0 : firstNonWS, true);\n    },\n    goLineEnd: function(cm) {cm.setSelection({line: cm.getCursor().line}, null, true);},\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharLeft: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharRight: function(cm) {cm.deleteH(1, \"char\");},\n    delWordLeft: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordRight: function(cm) {cm.deleteH(1, \"word\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\", \"end\");},\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        {line: cur.line, ch: cur.ch - 1}, {line: cur.line, ch: cur.ch + 1});\n    },\n    newlineAndIndent: function(cm) {\n      cm.replaceSelection(\"\\n\", \"end\");\n      cm.indentLine(cm.getCursor().line);\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharRight\", \"Backspace\": \"delCharLeft\", \"Tab\": \"indentMore\", \"Shift-Tab\": \"indentLess\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Alt-Up\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Down\": \"goDocEnd\",\n    \"Ctrl-Left\": \"goWordLeft\", \"Ctrl-Right\": \"goWordRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delWordLeft\", \"Ctrl-Delete\": \"delWordRight\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goWordLeft\",\n    \"Alt-Right\": \"goWordRight\", \"Cmd-Left\": \"goLineStart\", \"Cmd-Right\": \"goLineEnd\", \"Alt-Backspace\": \"delWordLeft\",\n    \"Ctrl-Alt-Backspace\": \"delWordRight\", \"Alt-Delete\": \"delWordRight\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageUp\", \"Shift-Ctrl-V\": \"goPageDown\", \"Ctrl-D\": \"delCharRight\", \"Ctrl-H\": \"delCharLeft\",\n    \"Alt-D\": \"delWordRight\", \"Alt-Backspace\": \"delWordLeft\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n\n  function lookupKey(name, extraMap, map) {\n    function lookup(name, map, ft) {\n      var found = map[name];\n      if (found != null) return found;\n      if (ft == null) ft = map.fallthrough;\n      if (ft == null) return map.catchall;\n      if (typeof ft == \"string\") return lookup(name, keyMap[ft]);\n      for (var i = 0, e = ft.length; i < e; ++i) {\n        found = lookup(name, keyMap[ft[i]]);\n        if (found != null) return found;\n      }\n      return null;\n    }\n    return extraMap ? lookup(name, extraMap, map) : lookup(name, keyMap[map]);\n  }\n  function isModifierKey(event) {\n    var name = keyNames[e_prop(event, \"keyCode\")];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n\n    function save() {textarea.value = instance.getValue();}\n    if (textarea.form) {\n      // Deplorable hack to make the submit method do the right thing.\n      var rmSubmit = connect(textarea.form, \"submit\", save, true);\n      if (typeof textarea.form.submit == \"function\") {\n        var realSubmit = textarea.form.submit;\n        function wrappedSubmit() {\n          save();\n          textarea.form.submit = realSubmit;\n          textarea.form.submit();\n          textarea.form.submit = wrappedSubmit;\n        }\n        textarea.form.submit = wrappedSubmit;\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var instance = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    instance.save = save;\n    instance.getTextArea = function() { return textarea; };\n    instance.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(instance.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        rmSubmit();\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return instance;\n  };\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n  }\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == 0;},\n    peek: function() {return this.string.charAt(this.pos);},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {return countColumn(this.string, this.start, this.tabSize);},\n    indentation: function() {return countColumn(this.string, null, this.tabSize);},\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        function cased(str) {return caseInsensitive ? str.toLowerCase() : str;}\n        if (cased(this.string).indexOf(cased(pattern), this.pos) == this.pos) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      }\n      else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);}\n  };\n  CodeMirror.StringStream = StringStream;\n\n  function MarkedText(from, to, className, set) {\n    this.from = from; this.to = to; this.style = className; this.set = set;\n  }\n  MarkedText.prototype = {\n    attach: function(line) { this.set.push(line); },\n    detach: function(line) {\n      var ix = indexOf(this.set, line);\n      if (ix > -1) this.set.splice(ix, 1);\n    },\n    split: function(pos, lenBefore) {\n      if (this.to <= pos && this.to != null) return null;\n      var from = this.from < pos || this.from == null ? null : this.from - pos + lenBefore;\n      var to = this.to == null ? null : this.to - pos + lenBefore;\n      return new MarkedText(from, to, this.style, this.set);\n    },\n    dup: function() { return new MarkedText(null, null, this.style, this.set); },\n    clipTo: function(fromOpen, from, toOpen, to, diff) {\n      if (this.from != null && this.from >= from)\n        this.from = Math.max(to, this.from) + diff;\n      if (this.to != null && this.to > from)\n        this.to = to < this.to ? this.to + diff : from;\n      if (fromOpen && to > this.from && (to < this.to || this.to == null))\n        this.from = null;\n      if (toOpen && (from < this.to || this.to == null) && (from > this.from || this.from == null))\n        this.to = null;\n    },\n    isDead: function() { return this.from != null && this.to != null && this.from >= this.to; },\n    sameSet: function(x) { return this.set == x.set; }\n  };\n\n  function Bookmark(pos) {\n    this.from = pos; this.to = pos; this.line = null;\n  }\n  Bookmark.prototype = {\n    attach: function(line) { this.line = line; },\n    detach: function(line) { if (this.line == line) this.line = null; },\n    split: function(pos, lenBefore) {\n      if (pos < this.from) {\n        this.from = this.to = (this.from - pos) + lenBefore;\n        return this;\n      }\n    },\n    isDead: function() { return this.from > this.to; },\n    clipTo: function(fromOpen, from, toOpen, to, diff) {\n      if ((fromOpen || from < this.from) && (toOpen || to > this.to)) {\n        this.from = 0; this.to = -1;\n      } else if (this.from > from) {\n        this.from = this.to = Math.max(to, this.from) + diff;\n      }\n    },\n    sameSet: function(x) { return false; },\n    find: function() {\n      if (!this.line || !this.line.parent) return null;\n      return {line: lineNo(this.line), ch: this.from};\n    },\n    clear: function() {\n      if (this.line) {\n        var found = indexOf(this.line.marked, this);\n        if (found != -1) this.line.marked.splice(found, 1);\n        this.line = null;\n      }\n    }\n  };\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  function Line(text, styles) {\n    this.styles = styles || [text, null];\n    this.text = text;\n    this.height = 1;\n    this.marked = this.gutterMarker = this.className = this.handlers = null;\n    this.stateAfter = this.parent = this.hidden = null;\n  }\n  Line.inheritMarks = function(text, orig) {\n    var ln = new Line(text), mk = orig && orig.marked;\n    if (mk) {\n      for (var i = 0; i < mk.length; ++i) {\n        if (mk[i].to == null && mk[i].style) {\n          var newmk = ln.marked || (ln.marked = []), mark = mk[i];\n          var nmark = mark.dup(); newmk.push(nmark); nmark.attach(ln);\n        }\n      }\n    }\n    return ln;\n  }\n  Line.prototype = {\n    // Replace a piece of a line, keeping the styles around it intact.\n    replace: function(from, to_, text) {\n      var st = [], mk = this.marked, to = to_ == null ? this.text.length : to_;\n      copyStyles(0, from, this.styles, st);\n      if (text) st.push(text, null);\n      copyStyles(to, this.text.length, this.styles, st);\n      this.styles = st;\n      this.text = this.text.slice(0, from) + text + this.text.slice(to);\n      this.stateAfter = null;\n      if (mk) {\n        var diff = text.length - (to - from);\n        for (var i = 0; i < mk.length; ++i) {\n          var mark = mk[i];\n          mark.clipTo(from == null, from || 0, to_ == null, to, diff);\n          if (mark.isDead()) {mark.detach(this); mk.splice(i--, 1);}\n        }\n      }\n    },\n    // Split a part off a line, keeping styles and markers intact.\n    split: function(pos, textBefore) {\n      var st = [textBefore, null], mk = this.marked;\n      copyStyles(pos, this.text.length, this.styles, st);\n      var taken = new Line(textBefore + this.text.slice(pos), st);\n      if (mk) {\n        for (var i = 0; i < mk.length; ++i) {\n          var mark = mk[i];\n          var newmark = mark.split(pos, textBefore.length);\n          if (newmark) {\n            if (!taken.marked) taken.marked = [];\n            taken.marked.push(newmark); newmark.attach(taken);\n          }\n        }\n      }\n      return taken;\n    },\n    append: function(line) {\n      var mylen = this.text.length, mk = line.marked, mymk = this.marked;\n      this.text += line.text;\n      copyStyles(0, line.text.length, line.styles, this.styles);\n      if (mymk) {\n        for (var i = 0; i < mymk.length; ++i)\n          if (mymk[i].to == null) mymk[i].to = mylen;\n      }\n      if (mk && mk.length) {\n        if (!mymk) this.marked = mymk = [];\n        outer: for (var i = 0; i < mk.length; ++i) {\n          var mark = mk[i];\n          if (!mark.from) {\n            for (var j = 0; j < mymk.length; ++j) {\n              var mymark = mymk[j];\n              if (mymark.to == mylen && mymark.sameSet(mark)) {\n                mymark.to = mark.to == null ? null : mark.to + mylen;\n                if (mymark.isDead()) {\n                  mymark.detach(this);\n                  mk.splice(i--, 1);\n                }\n                continue outer;\n              }\n            }\n          }\n          mymk.push(mark);\n          mark.attach(this);\n          mark.from += mylen;\n          if (mark.to != null) mark.to += mylen;\n        }\n      }\n    },\n    fixMarkEnds: function(other) {\n      var mk = this.marked, omk = other.marked;\n      if (!mk) return;\n      for (var i = 0; i < mk.length; ++i) {\n        var mark = mk[i], close = mark.to == null;\n        if (close && omk) {\n          for (var j = 0; j < omk.length; ++j)\n            if (omk[j].sameSet(mark)) {close = false; break;}\n        }\n        if (close) mark.to = this.text.length;\n      }\n    },\n    fixMarkStarts: function() {\n      var mk = this.marked;\n      if (!mk) return;\n      for (var i = 0; i < mk.length; ++i)\n        if (mk[i].from == null) mk[i].from = 0;\n    },\n    addMark: function(mark) {\n      mark.attach(this);\n      if (this.marked == null) this.marked = [];\n      this.marked.push(mark);\n      this.marked.sort(function(a, b){return (a.from || 0) - (b.from || 0);});\n    },\n    // Run the given mode's parser over a line, update the styles\n    // array, which contains alternating fragments of text and CSS\n    // classes.\n    highlight: function(mode, state, tabSize) {\n      var stream = new StringStream(this.text, tabSize), st = this.styles, pos = 0;\n      var changed = false, curWord = st[0], prevWord;\n      if (this.text == \"\" && mode.blankLine) mode.blankLine(state);\n      while (!stream.eol()) {\n        var style = mode.token(stream, state);\n        var substr = this.text.slice(stream.start, stream.pos);\n        stream.start = stream.pos;\n        if (pos && st[pos-1] == style)\n          st[pos-2] += substr;\n        else if (substr) {\n          if (!changed && (st[pos+1] != style || (pos && st[pos-2] != prevWord))) changed = true;\n          st[pos++] = substr; st[pos++] = style;\n          prevWord = curWord; curWord = st[pos];\n        }\n        // Give up when line is ridiculously long\n        if (stream.pos > 5000) {\n          st[pos++] = this.text.slice(stream.pos); st[pos++] = null;\n          break;\n        }\n      }\n      if (st.length != pos) {st.length = pos; changed = true;}\n      if (pos && st[pos-2] != prevWord) changed = true;\n      // Short lines with simple highlights return null, and are\n      // counted as changed by the driver because they are likely to\n      // highlight the same way in various contexts.\n      return changed || (st.length < 5 && this.text.length < 10 ? null : false);\n    },\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(mode, state, ch) {\n      var txt = this.text, stream = new StringStream(txt);\n      while (stream.pos < ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null,\n              state: state};\n    },\n    indentation: function(tabSize) {return countColumn(this.text, null, tabSize);},\n    // Produces an HTML fragment for the line, taking selection,\n    // marking, and highlighting into account.\n    getHTML: function(makeTab, endAt) {\n      var html = [], first = true, col = 0;\n      function span(text, style) {\n        if (!text) return;\n        // Work around a bug where, in some compat modes, IE ignores leading spaces\n        if (first && ie && text.charAt(0) == \" \") text = \"\\u00a0\" + text.slice(1);\n        first = false;\n        if (text.indexOf(\"\\t\") == -1) {\n          col += text.length;\n          var escaped = htmlEscape(text);\n        } else {\n          var escaped = \"\";\n          for (var pos = 0;;) {\n            var idx = text.indexOf(\"\\t\", pos);\n            if (idx == -1) {\n              escaped += htmlEscape(text.slice(pos));\n              col += text.length - pos;\n              break;\n            } else {\n              col += idx - pos;\n              var tab = makeTab(col);\n              escaped += htmlEscape(text.slice(pos, idx)) + tab.html;\n              col += tab.width;\n              pos = idx + 1;\n            }\n          }\n        }\n        if (style) html.push('<span class=\"', style, '\">', escaped, \"</span>\");\n        else html.push(escaped);\n      }\n      var st = this.styles, allText = this.text, marked = this.marked;\n      var len = allText.length;\n      if (endAt != null) len = Math.min(endAt, len);\n      function styleToClass(style) {\n        if (!style) return null;\n        return \"cm-\" + style.replace(/ +/g, \" cm-\");\n      }\n\n      if (!allText && endAt == null)\n        span(\" \");\n      else if (!marked || !marked.length)\n        for (var i = 0, ch = 0; ch < len; i+=2) {\n          var str = st[i], style = st[i+1], l = str.length;\n          if (ch + l > len) str = str.slice(0, len - ch);\n          ch += l;\n          span(str, styleToClass(style));\n        }\n      else {\n        var pos = 0, i = 0, text = \"\", style, sg = 0;\n        var nextChange = marked[0].from || 0, marks = [], markpos = 0;\n        function advanceMarks() {\n          var m;\n          while (markpos < marked.length &&\n                 ((m = marked[markpos]).from == pos || m.from == null)) {\n            if (m.style != null) marks.push(m);\n            ++markpos;\n          }\n          nextChange = markpos < marked.length ? marked[markpos].from : Infinity;\n          for (var i = 0; i < marks.length; ++i) {\n            var to = marks[i].to || Infinity;\n            if (to == pos) marks.splice(i--, 1);\n            else nextChange = Math.min(to, nextChange);\n          }\n        }\n        var m = 0;\n        while (pos < len) {\n          if (nextChange == pos) advanceMarks();\n          var upto = Math.min(len, nextChange);\n          while (true) {\n            if (text) {\n              var end = pos + text.length;\n              var appliedStyle = style;\n              for (var j = 0; j < marks.length; ++j)\n                appliedStyle = (appliedStyle ? appliedStyle + \" \" : \"\") + marks[j].style;\n              span(end > upto ? text.slice(0, upto - pos) : text, appliedStyle);\n              if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n              pos = end;\n            }\n            text = st[i++]; style = styleToClass(st[i++]);\n          }\n        }\n      }\n      return html.join(\"\");\n    },\n    cleanUp: function() {\n      this.parent = null;\n      if (this.marked)\n        for (var i = 0, e = this.marked.length; i < e; ++i) this.marked[i].detach(this);\n    }\n  };\n  // Utility used by replace and split above\n  function copyStyles(from, to, source, dest) {\n    for (var i = 0, pos = 0, state = 0; pos < to; i+=2) {\n      var part = source[i], end = pos + part.length;\n      if (state == 0) {\n        if (end > from) dest.push(part.slice(from - pos, Math.min(part.length, to - pos)), source[i+1]);\n        if (end >= from) state = 1;\n      }\n      else if (state == 1) {\n        if (end > to) dest.push(part.slice(0, to - pos), source[i+1]);\n        else dest.push(part, source[i+1]);\n      }\n      pos = end;\n    }\n  }\n\n  // Data structure that holds the sequence of lines.\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    remove: function(at, n, callbacks) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        line.cleanUp();\n        if (line.handlers)\n          for (var j = 0; j < line.handlers.length; ++j) callbacks.push(line.handlers[j]);\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertHeight: function(at, lines, height) {\n      this.height += height;\n      this.lines.splice.apply(this.lines, [at, 0].concat(lines));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    remove: function(at, n, callbacks) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.remove(at, rm, callbacks);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertHeight(at, lines, height);\n    },\n    insertHeight: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertHeight(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iter: function(from, to, op) { this.iterN(from, to - from, op); },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  function getLineAt(chunk, n) {\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0, e = chunk.children.length; ; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no;\n  }\n  function lineAtHeight(chunk, h) {\n    var n = 0;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n  function heightAtLine(chunk, n) {\n    var h = 0;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; continue outer; }\n        n -= sz;\n        h += child.height;\n      }\n      return h;\n    } while (!chunk.lines);\n    for (var i = 0; i < n; ++i) h += chunk.lines[i].height;\n    return h;\n  }\n\n  // The history object 'chunks' changes that are made close together\n  // and at almost the same time into bigger undoable units.\n  function History() {\n    this.time = 0;\n    this.done = []; this.undone = [];\n  }\n  History.prototype = {\n    addChange: function(start, added, old) {\n      this.undone.length = 0;\n      var time = +new Date, cur = this.done[this.done.length - 1], last = cur && cur[cur.length - 1];\n      var dtime = time - this.time;\n      if (dtime > 400 || !last) {\n        this.done.push([{start: start, added: added, old: old}]);\n      } else if (last.start > start + old.length || last.start + last.added < start - last.added + last.old.length) {\n        cur.push({start: start, added: added, old: old});\n      } else {\n        var oldoff = 0;\n        if (start < last.start) {\n          for (var i = last.start - start - 1; i >= 0; --i)\n            last.old.unshift(old[i]);\n          last.added += last.start - start;\n          last.start = start;\n        }\n        else if (last.start < start) {\n          oldoff = start - last.start;\n          added += oldoff;\n        }\n        for (var i = last.added - oldoff, e = old.length; i < e; ++i)\n          last.old.push(old[i]);\n        if (last.added < added) last.added = added;\n      }\n      this.time = time;\n    }\n  };\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    if (e.which) return e.which;\n    else if (e.button & 1) return 1;\n    else if (e.button & 2) return 3;\n    else if (e.button & 4) return 2;\n  }\n\n  // Allow 3rd-party code to override event properties by adding an override\n  // object to an event object.\n  function e_prop(e, prop) {\n    var overridden = e.override && e.override.hasOwnProperty(prop);\n    return overridden ? e.override[prop] : e[prop];\n  }\n\n  // Event handler registration. If disconnect is true, it'll return a\n  // function that unregisters the handler.\n  function connect(node, type, handler, disconnect) {\n    if (typeof node.addEventListener == \"function\") {\n      node.addEventListener(type, handler, false);\n      if (disconnect) return function() {node.removeEventListener(type, handler, false);};\n    }\n    else {\n      var wrapHandler = function(event) {handler(event || window.event);};\n      node.attachEvent(\"on\" + type, wrapHandler);\n      if (disconnect) return function() {node.detachEvent(\"on\" + type, wrapHandler);};\n    }\n  }\n  CodeMirror.connect = connect;\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // IE8 has ondragstart and ondrop properties, but doesn't seem to\n    // actually support ondragstart the way it's supposed to work.\n    if (/MSIE [1-8]\\b/.test(navigator.userAgent)) return false;\n    var div = document.createElement('div');\n    return \"draggable\" in div;\n  }();\n\n  var gecko = /gecko\\/\\d{7}/i.test(navigator.userAgent);\n  var ie = /MSIE \\d/.test(navigator.userAgent);\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n\n  var lineSep = \"\\n\";\n  // Feature-detect whether newlines in textareas are converted to \\r\\n\n  (function () {\n    var te = document.createElement(\"textarea\");\n    te.value = \"foo\\nbar\";\n    if (te.value.indexOf(\"\\r\") > -1) lineSep = \"\\r\\n\";\n  }());\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = 0, n = 0; i < end; ++i) {\n      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n\n  function computedStyle(elt) {\n    if (elt.currentStyle) return elt.currentStyle;\n    return window.getComputedStyle(elt, null);\n  }\n\n  // Find the position of an element by following the offsetParent chain.\n  // If screen==true, it returns screen (rather than page) coordinates.\n  function eltOffset(node, screen) {\n    var bod = node.ownerDocument.body;\n    var x = 0, y = 0, skipBody = false;\n    for (var n = node; n; n = n.offsetParent) {\n      var ol = n.offsetLeft, ot = n.offsetTop;\n      // Firefox reports weird inverted offsets when the body has a border.\n      if (n == bod) { x += Math.abs(ol); y += Math.abs(ot); }\n      else { x += ol, y += ot; }\n      if (screen && computedStyle(n).position == \"fixed\")\n        skipBody = true;\n    }\n    var e = screen && !skipBody ? null : bod;\n    for (var n = node.parentNode; n != e; n = n.parentNode)\n      if (n.scrollLeft != null) { x -= n.scrollLeft; y -= n.scrollTop;}\n    return {left: x, top: y};\n  }\n  // Use the faster and saner getBoundingClientRect method when possible.\n  if (document.documentElement.getBoundingClientRect != null) eltOffset = function(node, screen) {\n    // Take the parts of bounding client rect that we are interested in so we are able to edit if need be,\n    // since the returned value cannot be changed externally (they are kept in sync as the element moves within the page)\n    try { var box = node.getBoundingClientRect(); box = { top: box.top, left: box.left }; }\n    catch(e) { box = {top: 0, left: 0}; }\n    if (!screen) {\n      // Get the toplevel scroll, working around browser differences.\n      if (window.pageYOffset == null) {\n        var t = document.documentElement || document.body.parentNode;\n        if (t.scrollTop == null) t = document.body;\n        box.top += t.scrollTop; box.left += t.scrollLeft;\n      } else {\n        box.top += window.pageYOffset; box.left += window.pageXOffset;\n      }\n    }\n    return box;\n  };\n\n  // Get a node's text content.\n  function eltText(node) {\n    return node.textContent || node.innerText || node.nodeValue || \"\";\n  }\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else node.select();\n  }\n\n  // Operations on {line, ch} objects.\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function copyPos(x) {return {line: x.line, ch: x.ch};}\n\n  var escapeElement = document.createElement(\"pre\");\n  function htmlEscape(str) {\n    escapeElement.textContent = str;\n    return escapeElement.innerHTML;\n  }\n  // Recent (late 2011) Opera betas insert bogus newlines at the start\n  // of the textContent, so we strip those.\n  if (htmlEscape(\"a\") == \"\\na\")\n    htmlEscape = function(str) {\n      escapeElement.textContent = str;\n      return escapeElement.innerHTML.slice(1);\n    };\n  // Some IEs don't preserve tabs through innerHTML\n  else if (htmlEscape(\"\\t\") != \"\\t\")\n    htmlEscape = function(str) {\n      escapeElement.innerHTML = \"\";\n      escapeElement.appendChild(document.createTextNode(str));\n      return escapeElement.innerHTML;\n    };\n  CodeMirror.htmlEscape = htmlEscape;\n\n  // Used to position the cursor after an undo/redo by finding the\n  // last edited character.\n  function editEnd(from, to) {\n    if (!to) return 0;\n    if (!from) return to.length;\n    for (var i = from.length, j = to.length; i >= 0 && j >= 0; --i, --j)\n      if (from.charAt(i) != to.charAt(j)) break;\n    return j + 1;\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch.toUpperCase() != ch.toLowerCase();\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, nl, result = [];\n    while ((nl = string.indexOf(\"\\n\", pos)) > -1) {\n      result.push(string.slice(pos, string.charAt(nl-1) == \"\\r\" ? nl - 1 : nl));\n      pos = nl + 1;\n    }\n    result.push(string.slice(pos));\n    return result;\n  } : function(string){return string.split(/\\r?\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 186: \";\", 187: \"=\", 188: \",\",\n                  189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\", 221: \"]\", 222: \"'\", 63276: \"PageUp\",\n                  63277: \"PageDown\", 63275: \"End\", 63273: \"Home\", 63234: \"Left\", 63232: \"Up\", 63235: \"Right\",\n                  63233: \"Down\", 63302: \"Insert\", 63272: \"Delete\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  return CodeMirror;\n})();\n\n//xml.js\n\nCodeMirror.defineMode(\"xml\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {\"br\": true, \"img\": true, \"hr\": true, \"link\": true, \"input\": true,\n                      \"meta\": true, \"col\": true, \"frame\": true, \"base\": true, \"area\": true},\n    doNotIndent: {\"pre\": true},\n    allowUnquoted: true\n  } : {autoSelfClosers: {}, doNotIndent: {}, allowUnquoted: false};\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var tagName, type;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == \"<\") {\n      if (stream.eat(\"!\")) {\n        if (stream.eat(\"[\")) {\n          if (stream.match(\"CDATA[\")) return chain(inBlock(\"atom\", \"]]>\"));\n          else return null;\n        }\n        else if (stream.match(\"--\")) return chain(inBlock(\"comment\", \"-->\"));\n        else if (stream.match(\"DOCTYPE\", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        }\n        else return null;\n      }\n      else if (stream.eat(\"?\")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return \"meta\";\n      }\n      else {\n        type = stream.eat(\"/\") ? \"closeTag\" : \"openTag\";\n        stream.eatSpace();\n        tagName = \"\";\n        var c;\n        while ((c = stream.eat(/[^\\s\\u00a0=<>\\\"\\'\\/?]/))) tagName += c;\n        state.tokenize = inTag;\n        return \"tag\";\n      }\n    }\n    else if (ch == \"&\") {\n      var ok;\n      if (stream.eat(\"#\")) {\n        if (stream.eat(\"x\")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(\";\");          \n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(\";\");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w]/) && stream.eat(\";\");\n      }\n      return ok ? \"atom\" : \"error\";\n    }\n    else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == \">\" || (ch == \"/\" && stream.eat(\">\"))) {\n      state.tokenize = inText;\n      type = ch == \">\" ? \"endTag\" : \"selfcloseTag\";\n      return \"tag\";\n    }\n    else if (ch == \"=\") {\n      type = \"equals\";\n      return null;\n    }\n    else if (/[\\'\\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      return state.tokenize(stream, state);\n    }\n    else {\n      stream.eatWhile(/[^\\s\\u00a0=<>\\\"\\'\\/?]/);\n      return \"word\";\n    }\n  }\n\n  function inAttribute(quote) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return \"string\";\n    };\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == \"<\") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == \">\") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return \"meta\";\n    };\n  }\n\n  var curState, setStyle;\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n\n  function pushContext(tagName, startOfLine) {\n    var noIndent = Kludges.doNotIndent.hasOwnProperty(tagName) || (curState.context && curState.context.noIndent);\n    curState.context = {\n      prev: curState.context,\n      tagName: tagName,\n      indent: curState.indented,\n      startOfLine: startOfLine,\n      noIndent: noIndent\n    };\n  }\n  function popContext() {\n    if (curState.context) curState.context = curState.context.prev;\n  }\n\n  function element(type) {\n    if (type == \"openTag\") {\n      curState.tagName = tagName;\n      return cont(attributes, endtag(curState.startOfLine));\n    } else if (type == \"closeTag\") {\n      var err = false;\n      if (curState.context) {\n        err = curState.context.tagName != tagName;\n      } else {\n        err = true;\n      }\n      if (err) setStyle = \"error\";\n      return cont(endclosetag(err));\n    }\n    return cont();\n  }\n  function endtag(startOfLine) {\n    return function(type) {\n      if (type == \"selfcloseTag\" ||\n          (type == \"endTag\" && Kludges.autoSelfClosers.hasOwnProperty(curState.tagName.toLowerCase())))\n        return cont();\n      if (type == \"endTag\") {pushContext(curState.tagName, startOfLine); return cont();}\n      return cont();\n    };\n  }\n  function endclosetag(err) {\n    return function(type) {\n      if (err) setStyle = \"error\";\n      if (type == \"endTag\") { popContext(); return cont(); }\n      setStyle = \"error\";\n      return cont(arguments.callee);\n    }\n  }\n\n  function attributes(type) {\n    if (type == \"word\") {setStyle = \"attribute\"; return cont(attributes);}\n    if (type == \"equals\") return cont(attvalue, attributes);\n    if (type == \"string\") {setStyle = \"error\"; return cont(attributes);}\n    return pass();\n  }\n  function attvalue(type) {\n    if (type == \"word\" && Kludges.allowUnquoted) {setStyle = \"string\"; return cont();}\n    if (type == \"string\") return cont(attvaluemaybe);\n    return pass();\n  }\n  function attvaluemaybe(type) {\n    if (type == \"string\") return cont(attvaluemaybe);\n    else return pass();\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText, cc: [], indented: 0, startOfLine: true, tagName: null, context: null};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        state.startOfLine = true;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n\n      setStyle = type = tagName = null;\n      var style = state.tokenize(stream, state);\n      state.type = type;\n      if ((style || type) && style != \"comment\") {\n        curState = state;\n        while (true) {\n          var comb = state.cc.pop() || element;\n          if (comb(type || style)) break;\n        }\n      }\n      state.startOfLine = false;\n      return setStyle || style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      if ((state.tokenize != inTag && state.tokenize != inText) ||\n          context && context.noIndent)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      if (context && /^<\\//.test(textAfter))\n        context = context.prev;\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    compareStates: function(a, b) {\n      if (a.indented != b.indented || a.tokenize != b.tokenize) return false;\n      for (var ca = a.context, cb = b.context; ; ca = ca.prev, cb = cb.prev) {\n        if (!ca || !cb) return ca == cb;\n        if (ca.tagName != cb.tagName) return false;\n      }\n    },\n\n    electricChars: \"/\"\n  };\n});\n\nCodeMirror.defineMIME(\"application/xml\", \"xml\");\nCodeMirror.defineMIME(\"text/html\", {name: \"xml\", htmlMode: true});\n\n//dialog.js\n// Open simple dialogs on top of an editor. Relies on dialog.css.\n\n(function() {\n  function dialogDiv(cm, template) {\n    var wrap = cm.getWrapperElement();\n    var dialog = wrap.insertBefore(document.createElement(\"div\"), wrap.firstChild);\n    dialog.className = \"CodeMirror-dialog\";\n    dialog.innerHTML = '<div>' + template + '</div>';\n    return dialog;\n  }\n\n  CodeMirror.defineExtension(\"openDialog\", function(template, callback) {\n    var dialog = dialogDiv(this, template);\n    var closed = false, me = this;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n    }\n    var inp = dialog.getElementsByTagName(\"input\")[0];\n    if (inp) {\n      CodeMirror.connect(inp, \"keydown\", function(e) {\n        if (e.keyCode == 13 || e.keyCode == 27) {\n          CodeMirror.e_stop(e);\n          close();\n          me.focus();\n          if (e.keyCode == 13) callback(inp.value);\n        }\n      });\n      inp.focus();\n      CodeMirror.connect(inp, \"blur\", close);\n    }\n    return close;\n  });\n\n  CodeMirror.defineExtension(\"openConfirm\", function(template, callbacks) {\n    var dialog = dialogDiv(this, template);\n    var buttons = dialog.getElementsByTagName(\"button\");\n    var closed = false, me = this, blurring = 1;\n    function close() {\n      if (closed) return;\n      closed = true;\n      dialog.parentNode.removeChild(dialog);\n      me.focus();\n    }\n    buttons[0].focus();\n    for (var i = 0; i < buttons.length; ++i) {\n      var b = buttons[i];\n      (function(callback) {\n        CodeMirror.connect(b, \"click\", function(e) {\n          CodeMirror.e_preventDefault(e);\n          close();\n          if (callback) callback(me);\n        });\n      })(callbacks[i]);\n      CodeMirror.connect(b, \"blur\", function() {\n        --blurring;\n        setTimeout(function() { if (blurring <= 0) close(); }, 200);\n      });\n      CodeMirror.connect(b, \"focus\", function() { ++blurring; });\n    }\n  });\n})();\n\n\n\n\n//8888\n(function(){\n  function SearchCursor(cm, query, pos, caseFold) {\n    this.atOccurrence = false; this.cm = cm;\n    if (caseFold == null) caseFold = typeof query == \"string\" && query == query.toLowerCase();\n\n    pos = pos ? cm.clipPos(pos) : {line: 0, ch: 0};\n    this.pos = {from: pos, to: pos};\n\n    // The matches method is filled in based on the type of query.\n    // It takes a position and a direction, and returns an object\n    // describing the next occurrence of the query, or null if no\n    // more matches were found.\n    if (typeof query != \"string\") // Regexp match\n      this.matches = function(reverse, pos) {\n        if (reverse) {\n          var line = cm.getLine(pos.line).slice(0, pos.ch), match = line.match(query), start = 0;\n          while (match) {\n            var ind = line.indexOf(match[0]);\n            start += ind;\n            line = line.slice(ind + 1);\n            var newmatch = line.match(query);\n            if (newmatch) match = newmatch;\n            else break;\n            start++;\n          }\n        }\n        else {\n          var line = cm.getLine(pos.line).slice(pos.ch), match = line.match(query),\n          start = match && pos.ch + line.indexOf(match[0]);\n        }\n        if (match)\n          return {from: {line: pos.line, ch: start},\n                  to: {line: pos.line, ch: start + match[0].length},\n                  match: match};\n      };\n    else { // String query\n      if (caseFold) query = query.toLowerCase();\n      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\n      var target = query.split(\"\\n\");\n      // Different methods for single-line and multi-line queries\n      if (target.length == 1)\n        this.matches = function(reverse, pos) {\n          var line = fold(cm.getLine(pos.line)), len = query.length, match;\n          if (reverse ? (pos.ch >= len && (match = line.lastIndexOf(query, pos.ch - len)) != -1)\n              : (match = line.indexOf(query, pos.ch)) != -1)\n            return {from: {line: pos.line, ch: match},\n                    to: {line: pos.line, ch: match + len}};\n        };\n      else\n        this.matches = function(reverse, pos) {\n          var ln = pos.line, idx = (reverse ? target.length - 1 : 0), match = target[idx], line = fold(cm.getLine(ln));\n          var offsetA = (reverse ? line.indexOf(match) + match.length : line.lastIndexOf(match));\n          if (reverse ? offsetA >= pos.ch || offsetA != match.length\n              : offsetA <= pos.ch || offsetA != line.length - match.length)\n            return;\n          for (;;) {\n            if (reverse ? !ln : ln == cm.lineCount() - 1) return;\n            line = fold(cm.getLine(ln += reverse ? -1 : 1));\n            match = target[reverse ? --idx : ++idx];\n            if (idx > 0 && idx < target.length - 1) {\n              if (line != match) return;\n              else continue;\n            }\n            var offsetB = (reverse ? line.lastIndexOf(match) : line.indexOf(match) + match.length);\n            if (reverse ? offsetB != line.length - match.length : offsetB != match.length)\n              return;\n            var start = {line: pos.line, ch: offsetA}, end = {line: ln, ch: offsetB};\n            return {from: reverse ? end : start, to: reverse ? start : end};\n          }\n        };\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false);},\n    findPrevious: function() {return this.find(true);},\n\n    find: function(reverse) {\n      var self = this, pos = this.cm.clipPos(reverse ? this.pos.from : this.pos.to);\n      function savePosAndFail(line) {\n        var pos = {line: line, ch: 0};\n        self.pos = {from: pos, to: pos};\n        self.atOccurrence = false;\n        return false;\n      }\n\n      for (;;) {\n        if (this.pos = this.matches(reverse, pos)) {\n          this.atOccurrence = true;\n          return this.pos.match || true;\n        }\n        if (reverse) {\n          if (!pos.line) return savePosAndFail(0);\n          pos = {line: pos.line-1, ch: this.cm.getLine(pos.line-1).length};\n        }\n        else {\n          var maxLine = this.cm.lineCount();\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\n          pos = {line: pos.line+1, ch: 0};\n        }\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from;},\n    to: function() {if (this.atOccurrence) return this.pos.to;},\n\n    replace: function(newText) {\n      var self = this;\n      if (this.atOccurrence)\n        self.pos.to = this.cm.replaceRange(newText, self.pos.from, self.pos.to);\n    }\n  };\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold);\n  });\n})();\n\n\n//\n// Define search commands. Depends on dialog.js or another\n// implementation of the openDialog method.\n\n// Replace works a little oddly -- it will do the replace on the next\n// Ctrl-G (or whatever is bound to findNext) press. You prevent a\n// replace by making sure the match is no longer selected when hitting\n// Ctrl-G.\n\n(function() {\n  function SearchState() {\n    this.posFrom = this.posTo = this.query = null;\n    this.marked = [];\n  }\n  function getSearchState(cm) {\n    return cm._searchState || (cm._searchState = new SearchState());\n  }\n  function dialog(cm, text, shortText, f) {\n    if (cm.openDialog) cm.openDialog(text, f);\n    else f(prompt(shortText, \"\"));\n  }\n  function confirmDialog(cm, text, shortText, fs) {\n    if (cm.openConfirm) cm.openConfirm(text, fs);\n    else if (confirm(shortText)) fs[0]();\n  }\n  function parseQuery(query) {\n    var isRE = query.match(/^\\/(.*)\\/$/);\n    return isRE ? new RegExp(isRE[1]) : query;\n  }\n  var queryDialog =\n    'Search: <input type=\"text\" style=\"width: 10em\"> <span style=\"color: #888\">(Use /re/ syntax for regexp search)</span>';\n  function doSearch(cm, rev) {\n    var state = getSearchState(cm);\n    if (state.query) return findNext(cm, rev);\n    dialog(cm, queryDialog, \"Search for:\", function(query) {\n      cm.operation(function() {\n        if (!query || state.query) return;\n        state.query = parseQuery(query);\n        if (cm.lineCount() < 2000) { // This is too expensive on big documents.\n          for (var cursor = cm.getSearchCursor(query); cursor.findNext();)\n            state.marked.push(cm.markText(cursor.from(), cursor.to(), \"CodeMirror-searching\"));\n        }\n        state.posFrom = state.posTo = cm.getCursor();\n        findNext(cm, rev);\n      });\n    });\n  }\n  function findNext(cm, rev) {cm.operation(function() {\n    var state = getSearchState(cm);\n    var cursor = cm.getSearchCursor(state.query, rev ? state.posFrom : state.posTo);\n    if (!cursor.find(rev)) {\n      cursor = cm.getSearchCursor(state.query, rev ? {line: cm.lineCount() - 1} : {line: 0, ch: 0});\n      if (!cursor.find(rev)) return;\n    }\n    cm.setSelection(cursor.from(), cursor.to());\n    state.posFrom = cursor.from(); state.posTo = cursor.to();\n  })}\n  function clearSearch(cm) {cm.operation(function() {\n    var state = getSearchState(cm);\n    if (!state.query) return;\n    state.query = null;\n    for (var i = 0; i < state.marked.length; ++i) state.marked[i].clear();\n    state.marked.length = 0;\n  })}\n\n  var replaceQueryDialog =\n    'Replace: <input type=\"text\" style=\"width: 10em\"> <span style=\"color: #888\">(Use /re/ syntax for regexp search)</span>';\n  var replacementQueryDialog = 'With: <input type=\"text\" style=\"width: 10em\">';\n  var doReplaceConfirm = \"Replace? <button>Yes</button> <button>No</button> <button>Stop</button>\";\n  function replace(cm, all) {\n    dialog(cm, replaceQueryDialog, \"Replace:\", function(query) {\n      if (!query) return;\n      query = parseQuery(query);\n      dialog(cm, replacementQueryDialog, \"Replace with:\", function(text) {\n        if (all) {\n          cm.operation(function() {\n            for (var cursor = cm.getSearchCursor(query); cursor.findNext();) {\n              if (typeof query != \"string\") {\n                var match = cm.getRange(cursor.from(), cursor.to()).match(query);\n                cursor.replace(text.replace(/\\$(\\d)/, function(w, i) {return match[i];}));\n              } else cursor.replace(text);\n            }\n          });\n        } else {\n          clearSearch(cm);\n          var cursor = cm.getSearchCursor(query, cm.getCursor());\n          function advance() {\n            var start = cursor.from(), match;\n            if (!(match = cursor.findNext())) {\n              cursor = cm.getSearchCursor(query);\n              if (!(match = cursor.findNext()) ||\n                  (cursor.from().line == start.line && cursor.from().ch == start.ch)) return;\n            }\n            cm.setSelection(cursor.from(), cursor.to());\n            confirmDialog(cm, doReplaceConfirm, \"Replace?\",\n                          [function() {doReplace(match);}, advance]);\n          }\n          function doReplace(match) {\n            cursor.replace(typeof query == \"string\" ? text :\n                           text.replace(/\\$(\\d)/, function(w, i) {return match[i];}));\n            advance();\n          }\n          advance();\n        }\n      });\n    });\n  }\n\n  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};\n  CodeMirror.commands.findNext = doSearch;\n  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};\n  CodeMirror.commands.clearSearch = clearSearch;\n  CodeMirror.commands.replace = replace;\n  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};\n})();\n", "html" : "", "css" : ".CodeMirror {\n  line-height: 1em;\n  font-family: monospace;\n}\n\n.CodeMirror-scroll {\n  overflow: auto;\n  height: 300px;\n  /* This is needed to prevent an IE[67] bug where the scrolled content\n     is visible outside of the scrolling box. */\n  position: relative;\n}\n\n.CodeMirror-gutter {\n  position: absolute; left: 0; top: 0;\n  z-index: 10;\n  background-color: #f7f7f7;\n  border-right: 1px solid #eee;\n  min-width: 2em;\n  height: 100%;\n}\n.CodeMirror-gutter-text {\n  color: #aaa;\n  text-align: right;\n  padding: .4em .2em .4em .4em;\n  white-space: pre !important;\n}\n.CodeMirror-lines {\n  padding: .4em;\n}\n\n.CodeMirror pre {\n  -moz-border-radius: 0;\n  -webkit-border-radius: 0;\n  -o-border-radius: 0;\n  border-radius: 0;\n  border-width: 0; margin: 0; padding: 0; background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  padding: 0; margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n}\n\n.CodeMirror-wrap pre {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n}\n.CodeMirror-wrap .CodeMirror-scroll {\n  overflow-x: hidden;\n}\n\n.CodeMirror textarea {\n  outline: none !important;\n}\n\n.CodeMirror pre.CodeMirror-cursor {\n  z-index: 10;\n  position: absolute;\n  visibility: hidden;\n  border-left: 1px solid black;\n  border-right:none;\n  width:0;\n}\n.CodeMirror pre.CodeMirror-cursor.CodeMirror-overwrite {}\n.CodeMirror-focused pre.CodeMirror-cursor {\n  visibility: visible;\n}\n\ndiv.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused div.CodeMirror-selected { background: #d7d4f0; }\n\n.CodeMirror-searching {\n  background: #ffa;\n  background: rgba(255, 255, 0, .4);\n}\n\n/* Default theme */\n\n.cm-s-default span.cm-keyword {color: #708;}\n.cm-s-default span.cm-atom {color: #219;}\n.cm-s-default span.cm-number {color: #164;}\n.cm-s-default span.cm-def {color: #00f;}\n.cm-s-default span.cm-variable {color: black;}\n.cm-s-default span.cm-variable-2 {color: #05a;}\n.cm-s-default span.cm-variable-3 {color: #085;}\n.cm-s-default span.cm-property {color: black;}\n.cm-s-default span.cm-operator {color: black;}\n.cm-s-default span.cm-comment {color: #a50;}\n.cm-s-default span.cm-string {color: #a11;}\n.cm-s-default span.cm-string-2 {color: #f50;}\n.cm-s-default span.cm-meta {color: #555;}\n.cm-s-default span.cm-error {color: #f00;}\n.cm-s-default span.cm-qualifier {color: #555;}\n.cm-s-default span.cm-builtin {color: #30a;}\n.cm-s-default span.cm-bracket {color: #cc7;}\n.cm-s-default span.cm-tag {color: #170;}\n.cm-s-default span.cm-attribute {color: #00c;}\n.cm-s-default span.cm-header {color: #a0a;}\n.cm-s-default span.cm-quote {color: #090;}\n.cm-s-default span.cm-hr {color: #999;}\n.cm-s-default span.cm-link {color: #00c;}\n\nspan.cm-header, span.cm-strong {font-weight: bold;}\nspan.cm-em {font-style: italic;}\nspan.cm-emstrong {font-style: italic; font-weight: bold;}\nspan.cm-link {text-decoration: underline;}\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n\n//dialog.css\n.CodeMirror-dialog {\n  position: relative;\n}\n\n.CodeMirror-dialog > div {\n  position: absolute;\n  top: 0; left: 0; right: 0;\n  background: white;\n  border-bottom: 1px solid #eee;\n  z-index: 15;\n  padding: .1em .8em;\n  overflow: hidden;\n  color: #333;\n}\n\n.CodeMirror-dialog input {\n  border: none;\n  outline: none;\n  background: transparent;\n  width: 20em;\n  color: inherit;\n  font-family: monospace;\n}\n\n//" }
